{"ast":null,"code":"\"use strict\";\n\nvar _sliceInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\");\n\nvar _Array$from = require(\"@babel/runtime-corejs3/core-js-stable/array/from\");\n\nvar _Symbol = require(\"@babel/runtime-corejs3/core-js-stable/symbol\");\n\nvar _getIteratorMethod = require(\"@babel/runtime-corejs3/core-js/get-iterator-method\");\n\nvar _Array$isArray = require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\");\n\nvar _getIterator = require(\"@babel/runtime-corejs3/core-js/get-iterator\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it;\n\n  if (typeof _Symbol === \"undefined\" || _getIteratorMethod(o) == null) {\n    if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = _getIterator(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it[\"return\"] != null) it[\"return\"]();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  var _context4;\n\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n\n  var n = _sliceInstanceProperty(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1);\n\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return _Array$from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n/*!\n * XRegExp Unicode Base 5.0.2\n * <xregexp.com>\n * Steven Levithan (c) 2008-present MIT License\n */\n\n\nvar _default = function _default(XRegExp) {\n  /**\n   * Adds base support for Unicode matching:\n   * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n   *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n   *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n   * - Adds flag A (astral), which enables 21-bit Unicode support.\n   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n   *\n   * Unicode Base relies on externally provided Unicode character data. Official addons are\n   * available to provide data for Unicode categories, scripts, and properties.\n   *\n   * @requires XRegExp\n   */\n  // ==--------------------------==\n  // Private stuff\n  // ==--------------------------==\n  // Storage for Unicode data\n  var unicode = {};\n  var unicodeTypes = {}; // Reuse utils\n\n  var dec = XRegExp._dec;\n  var hex = XRegExp._hex;\n  var pad4 = XRegExp._pad4; // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\n\n  function normalize(name) {\n    return name.replace(/[- _]+/g, '').toLowerCase();\n  } // Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\n\n\n  function charCode(chr) {\n    var esc = /^\\\\[xu](.+)/.exec(chr);\n    return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === '\\\\' ? 1 : 0);\n  } // Inverts a list of ordered BMP characters and ranges\n\n\n  function invertBmp(range) {\n    var output = '';\n    var lastEnd = -1;\n    (0, _forEach[\"default\"])(XRegExp).call(XRegExp, range, /(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/, function (m) {\n      var start = charCode(m[1]);\n\n      if (start > lastEnd + 1) {\n        output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n        if (start > lastEnd + 2) {\n          output += \"-\\\\u\".concat(pad4(hex(start - 1)));\n        }\n      }\n\n      lastEnd = charCode(m[2] || m[1]);\n    });\n\n    if (lastEnd < 0xFFFF) {\n      output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n      if (lastEnd < 0xFFFE) {\n        output += '-\\\\uFFFF';\n      }\n    }\n\n    return output;\n  } // Generates an inverted BMP range on first use\n\n\n  function cacheInvertedBmp(slug) {\n    var prop = 'b!';\n    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));\n  } // Combines and optionally negates BMP and astral data\n\n\n  function buildAstral(slug, isNegated) {\n    var item = unicode[slug];\n    var combined = '';\n\n    if (item.bmp && !item.isBmpLast) {\n      var _context;\n\n      combined = (0, _concat[\"default\"])(_context = \"[\".concat(item.bmp, \"]\")).call(_context, item.astral ? '|' : '');\n    }\n\n    if (item.astral) {\n      combined += item.astral;\n    }\n\n    if (item.isBmpLast && item.bmp) {\n      var _context2;\n\n      combined += (0, _concat[\"default\"])(_context2 = \"\".concat(item.astral ? '|' : '', \"[\")).call(_context2, item.bmp, \"]\");\n    } // Astral Unicode tokens always match a code point, never a code unit\n\n\n    return isNegated ? \"(?:(?!\".concat(combined, \")(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))\") : \"(?:\".concat(combined, \")\");\n  } // Builds a complete astral pattern on first use\n\n\n  function cacheAstral(slug, isNegated) {\n    var prop = isNegated ? 'a!' : 'a=';\n    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));\n  } // ==--------------------------==\n  // Core functionality\n  // ==--------------------------==\n\n  /*\n   * Add astral mode (flag A) and Unicode token syntax: `\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`.\n   */\n\n\n  XRegExp.addToken( // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n  /\\\\([pP])(?:{(\\^?)(?:(\\w+)=)?([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {\n    var ERR_DOUBLE_NEG = 'Invalid double negation ';\n    var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\n    var ERR_UNKNOWN_REF = 'Unicode token missing data ';\n    var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\n    var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes';\n\n    var _match = (0, _slicedToArray2[\"default\"])(match, 6),\n        fullToken = _match[0],\n        pPrefix = _match[1],\n        caretNegation = _match[2],\n        typePrefix = _match[3],\n        tokenName = _match[4],\n        tokenSingleCharName = _match[5]; // Negated via \\P{..} or \\p{^..}\n\n\n    var isNegated = pPrefix === 'P' || !!caretNegation; // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\n\n    var isAstralMode = (0, _indexOf[\"default\"])(flags).call(flags, 'A') !== -1; // Token lookup name. Check `tokenSingleCharName` first to avoid passing `undefined`\n    // via `\\p{}`\n\n    var slug = normalize(tokenSingleCharName || tokenName); // Token data object\n\n    var item = unicode[slug];\n\n    if (pPrefix === 'P' && caretNegation) {\n      throw new SyntaxError(ERR_DOUBLE_NEG + fullToken);\n    }\n\n    if (!unicode.hasOwnProperty(slug)) {\n      throw new SyntaxError(ERR_UNKNOWN_NAME + fullToken);\n    }\n\n    if (typePrefix) {\n      if (!(unicodeTypes[typePrefix] && unicodeTypes[typePrefix][slug])) {\n        throw new SyntaxError(ERR_UNKNOWN_NAME + fullToken);\n      }\n    } // Switch to the negated form of the referenced Unicode token\n\n\n    if (item.inverseOf) {\n      slug = normalize(item.inverseOf);\n\n      if (!unicode.hasOwnProperty(slug)) {\n        var _context3;\n\n        throw new ReferenceError((0, _concat[\"default\"])(_context3 = \"\".concat(ERR_UNKNOWN_REF + fullToken, \" -> \")).call(_context3, item.inverseOf));\n      }\n\n      item = unicode[slug];\n      isNegated = !isNegated;\n    }\n\n    if (!(item.bmp || isAstralMode)) {\n      throw new SyntaxError(ERR_ASTRAL_ONLY + fullToken);\n    }\n\n    if (isAstralMode) {\n      if (scope === 'class') {\n        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\n      }\n\n      return cacheAstral(slug, isNegated);\n    }\n\n    return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : \"\".concat((isNegated ? '[^' : '[') + item.bmp, \"]\");\n  }, {\n    scope: 'all',\n    optionalFlags: 'A',\n    leadChar: '\\\\'\n  });\n  /**\n   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n   *\n   * @memberOf XRegExp\n   * @param {Array} data Objects with named character ranges. Each object may have properties\n   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n   *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n   *   character classes and alternation, and should use surrogate pairs to represent astral code\n   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n   *   defined as the exact inverse of another token.\n   * @param {String} [typePrefix] Enables optionally using this type as a prefix for all of the\n   *   provided Unicode tokens, e.g. if given `'Type'`, then `\\p{TokenName}` can also be written\n   *   as `\\p{Type=TokenName}`.\n   * @example\n   *\n   * // Basic use\n   * XRegExp.addUnicodeData([{\n   *   name: 'XDigit',\n   *   alias: 'Hexadecimal',\n   *   bmp: '0-9A-Fa-f'\n   * }]);\n   * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n   */\n\n  XRegExp.addUnicodeData = function (data, typePrefix) {\n    var ERR_NO_NAME = 'Unicode token requires name';\n    var ERR_NO_DATA = 'Unicode token has no character data ';\n\n    if (typePrefix) {\n      // Case sensitive to match ES2018\n      unicodeTypes[typePrefix] = {};\n    }\n\n    var _iterator = _createForOfIteratorHelper(data),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n\n        if (!item.name) {\n          throw new Error(ERR_NO_NAME);\n        }\n\n        if (!(item.inverseOf || item.bmp || item.astral)) {\n          throw new Error(ERR_NO_DATA + item.name);\n        }\n\n        var normalizedName = normalize(item.name);\n        unicode[normalizedName] = item;\n\n        if (typePrefix) {\n          unicodeTypes[typePrefix][normalizedName] = true;\n        }\n\n        if (item.alias) {\n          var normalizedAlias = normalize(item.alias);\n          unicode[normalizedAlias] = item;\n\n          if (typePrefix) {\n            unicodeTypes[typePrefix][normalizedAlias] = true;\n          }\n        }\n      } // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n      // flags might now produce different results\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    XRegExp.cache.flush('patterns');\n  };\n  /**\n   * @ignore\n   *\n   * Return a reference to the internal Unicode definition structure for the given Unicode\n   * Property if the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex\n   * constructs.\n   *\n   * @memberOf XRegExp\n   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\n   *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\n   *   Properties and Property Aliases.\n   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\n   *\n   * @note\n   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n   *\n   * @note\n   * This method is *not* part of the officially documented API and may change or be removed in\n   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\n   * structures set up by XRegExp.\n   */\n\n\n  XRegExp._getUnicodeProperty = function (name) {\n    var slug = normalize(name);\n    return unicode[slug];\n  };\n};\n\nexports[\"default\"] = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["E:/AcademicAdvisingSystem/client/node_modules/xregexp/lib/addons/unicode-base.js"],"names":["_sliceInstanceProperty","require","_Array$from","_Symbol","_getIteratorMethod","_Array$isArray","_getIterator","_Object$defineProperty","_interopRequireDefault","exports","value","_slicedToArray2","_forEach","_concat","_indexOf","_createForOfIteratorHelper","o","allowArrayLike","it","_unsupportedIterableToArray","length","i","F","s","n","done","e","_e","f","TypeError","normalCompletion","didErr","err","step","next","_e2","minLen","_context4","_arrayLikeToArray","Object","prototype","toString","call","constructor","name","test","arr","len","arr2","Array","_default","XRegExp","unicode","unicodeTypes","dec","_dec","hex","_hex","pad4","_pad4","normalize","replace","toLowerCase","charCode","chr","esc","exec","charCodeAt","invertBmp","range","output","lastEnd","m","start","concat","cacheInvertedBmp","slug","prop","bmp","buildAstral","isNegated","item","combined","isBmpLast","_context","astral","_context2","cacheAstral","addToken","match","scope","flags","ERR_DOUBLE_NEG","ERR_UNKNOWN_NAME","ERR_UNKNOWN_REF","ERR_ASTRAL_ONLY","ERR_ASTRAL_IN_CLASS","_match","fullToken","pPrefix","caretNegation","typePrefix","tokenName","tokenSingleCharName","isAstralMode","SyntaxError","hasOwnProperty","inverseOf","_context3","ReferenceError","optionalFlags","leadChar","addUnicodeData","data","ERR_NO_NAME","ERR_NO_DATA","_iterator","_step","Error","normalizedName","alias","normalizedAlias","cache","flush","_getUnicodeProperty","module","default"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,sDAAD,CAApC;;AAEA,IAAIC,WAAW,GAAGD,OAAO,CAAC,kDAAD,CAAzB;;AAEA,IAAIE,OAAO,GAAGF,OAAO,CAAC,8CAAD,CAArB;;AAEA,IAAIG,kBAAkB,GAAGH,OAAO,CAAC,oDAAD,CAAhC;;AAEA,IAAII,cAAc,GAAGJ,OAAO,CAAC,sDAAD,CAA5B;;AAEA,IAAIK,YAAY,GAAGL,OAAO,CAAC,6CAAD,CAA1B;;AAEA,IAAIM,sBAAsB,GAAGN,OAAO,CAAC,8DAAD,CAApC;;AAEA,IAAIO,sBAAsB,GAAGP,OAAO,CAAC,sDAAD,CAApC;;AAEAM,sBAAsB,CAACE,OAAD,EAAU,YAAV,EAAwB;AAC5CC,EAAAA,KAAK,EAAE;AADqC,CAAxB,CAAtB;;AAIAD,OAAO,CAAC,SAAD,CAAP,GAAqB,KAAK,CAA1B;;AAEA,IAAIE,eAAe,GAAGH,sBAAsB,CAACP,OAAO,CAAC,8CAAD,CAAR,CAA5C;;AAEA,IAAIW,QAAQ,GAAGJ,sBAAsB,CAACP,OAAO,CAAC,yDAAD,CAAR,CAArC;;AAEA,IAAIY,OAAO,GAAGL,sBAAsB,CAACP,OAAO,CAAC,uDAAD,CAAR,CAApC;;AAEA,IAAIa,QAAQ,GAAGN,sBAAsB,CAACP,OAAO,CAAC,yDAAD,CAAR,CAArC;;AAEA,SAASc,0BAAT,CAAoCC,CAApC,EAAuCC,cAAvC,EAAuD;AAAE,MAAIC,EAAJ;;AAAQ,MAAI,OAAOf,OAAP,KAAmB,WAAnB,IAAkCC,kBAAkB,CAACY,CAAD,CAAlB,IAAyB,IAA/D,EAAqE;AAAE,QAAIX,cAAc,CAACW,CAAD,CAAd,KAAsBE,EAAE,GAAGC,2BAA2B,CAACH,CAAD,CAAtD,KAA8DC,cAAc,IAAID,CAAlB,IAAuB,OAAOA,CAAC,CAACI,MAAT,KAAoB,QAA7G,EAAuH;AAAE,UAAIF,EAAJ,EAAQF,CAAC,GAAGE,EAAJ;AAAQ,UAAIG,CAAC,GAAG,CAAR;;AAAW,UAAIC,CAAC,GAAG,SAASA,CAAT,GAAa,CAAE,CAAvB;;AAAyB,aAAO;AAAEC,QAAAA,CAAC,EAAED,CAAL;AAAQE,QAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAE,cAAIH,CAAC,IAAIL,CAAC,CAACI,MAAX,EAAmB,OAAO;AAAEK,YAAAA,IAAI,EAAE;AAAR,WAAP;AAAuB,iBAAO;AAAEA,YAAAA,IAAI,EAAE,KAAR;AAAef,YAAAA,KAAK,EAAEM,CAAC,CAACK,CAAC,EAAF;AAAvB,WAAP;AAAwC,SAA5G;AAA8GK,QAAAA,CAAC,EAAE,SAASA,CAAT,CAAWC,EAAX,EAAe;AAAE,gBAAMA,EAAN;AAAW,SAA7I;AAA+IC,QAAAA,CAAC,EAAEN;AAAlJ,OAAP;AAA+J;;AAAC,UAAM,IAAIO,SAAJ,CAAc,uIAAd,CAAN;AAA+J;;AAAC,MAAIC,gBAAgB,GAAG,IAAvB;AAAA,MAA6BC,MAAM,GAAG,KAAtC;AAAA,MAA6CC,GAA7C;AAAkD,SAAO;AAAET,IAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAEL,MAAAA,EAAE,GAAGZ,YAAY,CAACU,CAAD,CAAjB;AAAuB,KAA3C;AAA6CQ,IAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAE,UAAIS,IAAI,GAAGf,EAAE,CAACgB,IAAH,EAAX;AAAsBJ,MAAAA,gBAAgB,GAAGG,IAAI,CAACR,IAAxB;AAA8B,aAAOQ,IAAP;AAAc,KAAjI;AAAmIP,IAAAA,CAAC,EAAE,SAASA,CAAT,CAAWS,GAAX,EAAgB;AAAEJ,MAAAA,MAAM,GAAG,IAAT;AAAeC,MAAAA,GAAG,GAAGG,GAAN;AAAY,KAAnL;AAAqLP,IAAAA,CAAC,EAAE,SAASA,CAAT,GAAa;AAAE,UAAI;AAAE,YAAI,CAACE,gBAAD,IAAqBZ,EAAE,CAAC,QAAD,CAAF,IAAgB,IAAzC,EAA+CA,EAAE,CAAC,QAAD,CAAF;AAAiB,OAAtE,SAA+E;AAAE,YAAIa,MAAJ,EAAY,MAAMC,GAAN;AAAY;AAAE;AAAlT,GAAP;AAA8T;;AAEr+B,SAASb,2BAAT,CAAqCH,CAArC,EAAwCoB,MAAxC,EAAgD;AAAE,MAAIC,SAAJ;;AAAe,MAAI,CAACrB,CAAL,EAAQ;AAAQ,MAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B,OAAOsB,iBAAiB,CAACtB,CAAD,EAAIoB,MAAJ,CAAxB;;AAAqC,MAAIZ,CAAC,GAAGxB,sBAAsB,CAACqC,SAAS,GAAGE,MAAM,CAACC,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+B1B,CAA/B,CAAb,CAAtB,CAAsE0B,IAAtE,CAA2EL,SAA3E,EAAsF,CAAtF,EAAyF,CAAC,CAA1F,CAAR;;AAAsG,MAAIb,CAAC,KAAK,QAAN,IAAkBR,CAAC,CAAC2B,WAAxB,EAAqCnB,CAAC,GAAGR,CAAC,CAAC2B,WAAF,CAAcC,IAAlB;AAAwB,MAAIpB,CAAC,KAAK,KAAN,IAAeA,CAAC,KAAK,KAAzB,EAAgC,OAAOtB,WAAW,CAACc,CAAD,CAAlB;AAAuB,MAAIQ,CAAC,KAAK,WAAN,IAAqB,2CAA2CqB,IAA3C,CAAgDrB,CAAhD,CAAzB,EAA6E,OAAOc,iBAAiB,CAACtB,CAAD,EAAIoB,MAAJ,CAAxB;AAAsC;;AAE9d,SAASE,iBAAT,CAA2BQ,GAA3B,EAAgCC,GAAhC,EAAqC;AAAE,MAAIA,GAAG,IAAI,IAAP,IAAeA,GAAG,GAAGD,GAAG,CAAC1B,MAA7B,EAAqC2B,GAAG,GAAGD,GAAG,CAAC1B,MAAV;;AAAkB,OAAK,IAAIC,CAAC,GAAG,CAAR,EAAW2B,IAAI,GAAG,IAAIC,KAAJ,CAAUF,GAAV,CAAvB,EAAuC1B,CAAC,GAAG0B,GAA3C,EAAgD1B,CAAC,EAAjD,EAAqD;AAAE2B,IAAAA,IAAI,CAAC3B,CAAD,CAAJ,GAAUyB,GAAG,CAACzB,CAAD,CAAb;AAAmB;;AAAC,SAAO2B,IAAP;AAAc;AAEvL;AACA;AACA;AACA;AACA;;;AACA,IAAIE,QAAQ,GAAG,SAASA,QAAT,CAAkBC,OAAlB,EAA2B;AACxC;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE;AACA;AACA;AACA;AACA,MAAIC,OAAO,GAAG,EAAd;AACA,MAAIC,YAAY,GAAG,EAAnB,CAnBwC,CAmBjB;;AAEvB,MAAIC,GAAG,GAAGH,OAAO,CAACI,IAAlB;AACA,MAAIC,GAAG,GAAGL,OAAO,CAACM,IAAlB;AACA,MAAIC,IAAI,GAAGP,OAAO,CAACQ,KAAnB,CAvBwC,CAuBd;;AAE1B,WAASC,SAAT,CAAmBhB,IAAnB,EAAyB;AACvB,WAAOA,IAAI,CAACiB,OAAL,CAAa,SAAb,EAAwB,EAAxB,EAA4BC,WAA5B,EAAP;AACD,GA3BuC,CA2BtC;;;AAGF,WAASC,QAAT,CAAkBC,GAAlB,EAAuB;AACrB,QAAIC,GAAG,GAAG,cAAcC,IAAd,CAAmBF,GAAnB,CAAV;AACA,WAAOC,GAAG,GAAGX,GAAG,CAACW,GAAG,CAAC,CAAD,CAAJ,CAAN,GAAiBD,GAAG,CAACG,UAAJ,CAAeH,GAAG,CAAC,CAAD,CAAH,KAAW,IAAX,GAAkB,CAAlB,GAAsB,CAArC,CAA3B;AACD,GAjCuC,CAiCtC;;;AAGF,WAASI,SAAT,CAAmBC,KAAnB,EAA0B;AACxB,QAAIC,MAAM,GAAG,EAAb;AACA,QAAIC,OAAO,GAAG,CAAC,CAAf;AACA,KAAC,GAAG3D,QAAQ,CAAC,SAAD,CAAZ,EAAyBuC,OAAzB,EAAkCT,IAAlC,CAAuCS,OAAvC,EAAgDkB,KAAhD,EAAuD,0DAAvD,EAAmH,UAAUG,CAAV,EAAa;AAC9H,UAAIC,KAAK,GAAGV,QAAQ,CAACS,CAAC,CAAC,CAAD,CAAF,CAApB;;AAEA,UAAIC,KAAK,GAAGF,OAAO,GAAG,CAAtB,EAAyB;AACvBD,QAAAA,MAAM,IAAI,MAAMI,MAAN,CAAahB,IAAI,CAACF,GAAG,CAACe,OAAO,GAAG,CAAX,CAAJ,CAAjB,CAAV;;AAEA,YAAIE,KAAK,GAAGF,OAAO,GAAG,CAAtB,EAAyB;AACvBD,UAAAA,MAAM,IAAI,OAAOI,MAAP,CAAchB,IAAI,CAACF,GAAG,CAACiB,KAAK,GAAG,CAAT,CAAJ,CAAlB,CAAV;AACD;AACF;;AAEDF,MAAAA,OAAO,GAAGR,QAAQ,CAACS,CAAC,CAAC,CAAD,CAAD,IAAQA,CAAC,CAAC,CAAD,CAAV,CAAlB;AACD,KAZD;;AAcA,QAAID,OAAO,GAAG,MAAd,EAAsB;AACpBD,MAAAA,MAAM,IAAI,MAAMI,MAAN,CAAahB,IAAI,CAACF,GAAG,CAACe,OAAO,GAAG,CAAX,CAAJ,CAAjB,CAAV;;AAEA,UAAIA,OAAO,GAAG,MAAd,EAAsB;AACpBD,QAAAA,MAAM,IAAI,UAAV;AACD;AACF;;AAED,WAAOA,MAAP;AACD,GA9DuC,CA8DtC;;;AAGF,WAASK,gBAAT,CAA0BC,IAA1B,EAAgC;AAC9B,QAAIC,IAAI,GAAG,IAAX;AACA,WAAOzB,OAAO,CAACwB,IAAD,CAAP,CAAcC,IAAd,MAAwBzB,OAAO,CAACwB,IAAD,CAAP,CAAcC,IAAd,IAAsBT,SAAS,CAAChB,OAAO,CAACwB,IAAD,CAAP,CAAcE,GAAf,CAAvD,CAAP;AACD,GApEuC,CAoEtC;;;AAGF,WAASC,WAAT,CAAqBH,IAArB,EAA2BI,SAA3B,EAAsC;AACpC,QAAIC,IAAI,GAAG7B,OAAO,CAACwB,IAAD,CAAlB;AACA,QAAIM,QAAQ,GAAG,EAAf;;AAEA,QAAID,IAAI,CAACH,GAAL,IAAY,CAACG,IAAI,CAACE,SAAtB,EAAiC;AAC/B,UAAIC,QAAJ;;AAEAF,MAAAA,QAAQ,GAAG,CAAC,GAAGrE,OAAO,CAAC,SAAD,CAAX,EAAwBuE,QAAQ,GAAG,IAAIV,MAAJ,CAAWO,IAAI,CAACH,GAAhB,EAAqB,GAArB,CAAnC,EAA8DpC,IAA9D,CAAmE0C,QAAnE,EAA6EH,IAAI,CAACI,MAAL,GAAc,GAAd,GAAoB,EAAjG,CAAX;AACD;;AAED,QAAIJ,IAAI,CAACI,MAAT,EAAiB;AACfH,MAAAA,QAAQ,IAAID,IAAI,CAACI,MAAjB;AACD;;AAED,QAAIJ,IAAI,CAACE,SAAL,IAAkBF,IAAI,CAACH,GAA3B,EAAgC;AAC9B,UAAIQ,SAAJ;;AAEAJ,MAAAA,QAAQ,IAAI,CAAC,GAAGrE,OAAO,CAAC,SAAD,CAAX,EAAwByE,SAAS,GAAG,GAAGZ,MAAH,CAAUO,IAAI,CAACI,MAAL,GAAc,GAAd,GAAoB,EAA9B,EAAkC,GAAlC,CAApC,EAA4E3C,IAA5E,CAAiF4C,SAAjF,EAA4FL,IAAI,CAACH,GAAjG,EAAsG,GAAtG,CAAZ;AACD,KAlBmC,CAkBlC;;;AAGF,WAAOE,SAAS,GAAG,SAASN,MAAT,CAAgBQ,QAAhB,EAA0B,kDAA1B,CAAH,GAAmF,MAAMR,MAAN,CAAaQ,QAAb,EAAuB,GAAvB,CAAnG;AACD,GA7FuC,CA6FtC;;;AAGF,WAASK,WAAT,CAAqBX,IAArB,EAA2BI,SAA3B,EAAsC;AACpC,QAAIH,IAAI,GAAGG,SAAS,GAAG,IAAH,GAAU,IAA9B;AACA,WAAO5B,OAAO,CAACwB,IAAD,CAAP,CAAcC,IAAd,MAAwBzB,OAAO,CAACwB,IAAD,CAAP,CAAcC,IAAd,IAAsBE,WAAW,CAACH,IAAD,EAAOI,SAAP,CAAzD,CAAP;AACD,GAnGuC,CAmGtC;AACF;AACA;;AAEA;AACF;AACA;;;AAGE7B,EAAAA,OAAO,CAACqC,QAAR,EAAkB;AAClB,oDADA,EACoD,UAAUC,KAAV,EAAiBC,KAAjB,EAAwBC,KAAxB,EAA+B;AACjF,QAAIC,cAAc,GAAG,0BAArB;AACA,QAAIC,gBAAgB,GAAG,wBAAvB;AACA,QAAIC,eAAe,GAAG,6BAAtB;AACA,QAAIC,eAAe,GAAG,yCAAtB;AACA,QAAIC,mBAAmB,GAAG,sEAA1B;;AAEA,QAAIC,MAAM,GAAG,CAAC,GAAGtF,eAAe,CAAC,SAAD,CAAnB,EAAgC8E,KAAhC,EAAuC,CAAvC,CAAb;AAAA,QACIS,SAAS,GAAGD,MAAM,CAAC,CAAD,CADtB;AAAA,QAEIE,OAAO,GAAGF,MAAM,CAAC,CAAD,CAFpB;AAAA,QAGIG,aAAa,GAAGH,MAAM,CAAC,CAAD,CAH1B;AAAA,QAIII,UAAU,GAAGJ,MAAM,CAAC,CAAD,CAJvB;AAAA,QAKIK,SAAS,GAAGL,MAAM,CAAC,CAAD,CALtB;AAAA,QAMIM,mBAAmB,GAAGN,MAAM,CAAC,CAAD,CANhC,CAPiF,CAa5C;;;AAGrC,QAAIjB,SAAS,GAAGmB,OAAO,KAAK,GAAZ,IAAmB,CAAC,CAACC,aAArC,CAhBiF,CAgB7B;;AAEpD,QAAII,YAAY,GAAG,CAAC,GAAG1F,QAAQ,CAAC,SAAD,CAAZ,EAAyB6E,KAAzB,EAAgCjD,IAAhC,CAAqCiD,KAArC,EAA4C,GAA5C,MAAqD,CAAC,CAAzE,CAlBiF,CAkBL;AAC5E;;AAEA,QAAIf,IAAI,GAAGhB,SAAS,CAAC2C,mBAAmB,IAAID,SAAxB,CAApB,CArBiF,CAqBzB;;AAExD,QAAIrB,IAAI,GAAG7B,OAAO,CAACwB,IAAD,CAAlB;;AAEA,QAAIuB,OAAO,KAAK,GAAZ,IAAmBC,aAAvB,EAAsC;AACpC,YAAM,IAAIK,WAAJ,CAAgBb,cAAc,GAAGM,SAAjC,CAAN;AACD;;AAED,QAAI,CAAC9C,OAAO,CAACsD,cAAR,CAAuB9B,IAAvB,CAAL,EAAmC;AACjC,YAAM,IAAI6B,WAAJ,CAAgBZ,gBAAgB,GAAGK,SAAnC,CAAN;AACD;;AAED,QAAIG,UAAJ,EAAgB;AACd,UAAI,EAAEhD,YAAY,CAACgD,UAAD,CAAZ,IAA4BhD,YAAY,CAACgD,UAAD,CAAZ,CAAyBzB,IAAzB,CAA9B,CAAJ,EAAmE;AACjE,cAAM,IAAI6B,WAAJ,CAAgBZ,gBAAgB,GAAGK,SAAnC,CAAN;AACD;AACF,KArCgF,CAqC/E;;;AAGF,QAAIjB,IAAI,CAAC0B,SAAT,EAAoB;AAClB/B,MAAAA,IAAI,GAAGhB,SAAS,CAACqB,IAAI,CAAC0B,SAAN,CAAhB;;AAEA,UAAI,CAACvD,OAAO,CAACsD,cAAR,CAAuB9B,IAAvB,CAAL,EAAmC;AACjC,YAAIgC,SAAJ;;AAEA,cAAM,IAAIC,cAAJ,CAAmB,CAAC,GAAGhG,OAAO,CAAC,SAAD,CAAX,EAAwB+F,SAAS,GAAG,GAAGlC,MAAH,CAAUoB,eAAe,GAAGI,SAA5B,EAAuC,MAAvC,CAApC,EAAoFxD,IAApF,CAAyFkE,SAAzF,EAAoG3B,IAAI,CAAC0B,SAAzG,CAAnB,CAAN;AACD;;AAED1B,MAAAA,IAAI,GAAG7B,OAAO,CAACwB,IAAD,CAAd;AACAI,MAAAA,SAAS,GAAG,CAACA,SAAb;AACD;;AAED,QAAI,EAAEC,IAAI,CAACH,GAAL,IAAY0B,YAAd,CAAJ,EAAiC;AAC/B,YAAM,IAAIC,WAAJ,CAAgBV,eAAe,GAAGG,SAAlC,CAAN;AACD;;AAED,QAAIM,YAAJ,EAAkB;AAChB,UAAId,KAAK,KAAK,OAAd,EAAuB;AACrB,cAAM,IAAIe,WAAJ,CAAgBT,mBAAhB,CAAN;AACD;;AAED,aAAOT,WAAW,CAACX,IAAD,EAAOI,SAAP,CAAlB;AACD;;AAED,WAAOU,KAAK,KAAK,OAAV,GAAoBV,SAAS,GAAGL,gBAAgB,CAACC,IAAD,CAAnB,GAA4BK,IAAI,CAACH,GAA9D,GAAoE,GAAGJ,MAAH,CAAU,CAACM,SAAS,GAAG,IAAH,GAAU,GAApB,IAA2BC,IAAI,CAACH,GAA1C,EAA+C,GAA/C,CAA3E;AACD,GAnED,EAmEG;AACDY,IAAAA,KAAK,EAAE,KADN;AAEDoB,IAAAA,aAAa,EAAE,GAFd;AAGDC,IAAAA,QAAQ,EAAE;AAHT,GAnEH;AAwEA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEE5D,EAAAA,OAAO,CAAC6D,cAAR,GAAyB,UAAUC,IAAV,EAAgBZ,UAAhB,EAA4B;AACnD,QAAIa,WAAW,GAAG,6BAAlB;AACA,QAAIC,WAAW,GAAG,sCAAlB;;AAEA,QAAId,UAAJ,EAAgB;AACd;AACAhD,MAAAA,YAAY,CAACgD,UAAD,CAAZ,GAA2B,EAA3B;AACD;;AAED,QAAIe,SAAS,GAAGrG,0BAA0B,CAACkG,IAAD,CAA1C;AAAA,QACII,KADJ;;AAGA,QAAI;AACF,WAAKD,SAAS,CAAC7F,CAAV,EAAL,EAAoB,CAAC,CAAC8F,KAAK,GAAGD,SAAS,CAAC5F,CAAV,EAAT,EAAwBC,IAA7C,GAAoD;AAClD,YAAIwD,IAAI,GAAGoC,KAAK,CAAC3G,KAAjB;;AAEA,YAAI,CAACuE,IAAI,CAACrC,IAAV,EAAgB;AACd,gBAAM,IAAI0E,KAAJ,CAAUJ,WAAV,CAAN;AACD;;AAED,YAAI,EAAEjC,IAAI,CAAC0B,SAAL,IAAkB1B,IAAI,CAACH,GAAvB,IAA8BG,IAAI,CAACI,MAArC,CAAJ,EAAkD;AAChD,gBAAM,IAAIiC,KAAJ,CAAUH,WAAW,GAAGlC,IAAI,CAACrC,IAA7B,CAAN;AACD;;AAED,YAAI2E,cAAc,GAAG3D,SAAS,CAACqB,IAAI,CAACrC,IAAN,CAA9B;AACAQ,QAAAA,OAAO,CAACmE,cAAD,CAAP,GAA0BtC,IAA1B;;AAEA,YAAIoB,UAAJ,EAAgB;AACdhD,UAAAA,YAAY,CAACgD,UAAD,CAAZ,CAAyBkB,cAAzB,IAA2C,IAA3C;AACD;;AAED,YAAItC,IAAI,CAACuC,KAAT,EAAgB;AACd,cAAIC,eAAe,GAAG7D,SAAS,CAACqB,IAAI,CAACuC,KAAN,CAA/B;AACApE,UAAAA,OAAO,CAACqE,eAAD,CAAP,GAA2BxC,IAA3B;;AAEA,cAAIoB,UAAJ,EAAgB;AACdhD,YAAAA,YAAY,CAACgD,UAAD,CAAZ,CAAyBoB,eAAzB,IAA4C,IAA5C;AACD;AACF;AACF,OA3BC,CA2BA;AACF;;AAED,KA9BD,CA8BE,OAAOzF,GAAP,EAAY;AACZoF,MAAAA,SAAS,CAAC1F,CAAV,CAAYM,GAAZ;AACD,KAhCD,SAgCU;AACRoF,MAAAA,SAAS,CAACxF,CAAV;AACD;;AAEDuB,IAAAA,OAAO,CAACuE,KAAR,CAAcC,KAAd,CAAoB,UAApB;AACD,GAjDD;AAkDA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGExE,EAAAA,OAAO,CAACyE,mBAAR,GAA8B,UAAUhF,IAAV,EAAgB;AAC5C,QAAIgC,IAAI,GAAGhB,SAAS,CAAChB,IAAD,CAApB;AACA,WAAOQ,OAAO,CAACwB,IAAD,CAAd;AACD,GAHD;AAID,CAjSD;;AAmSAnE,OAAO,CAAC,SAAD,CAAP,GAAqByC,QAArB;AACA2E,MAAM,CAACpH,OAAP,GAAiBA,OAAO,CAACqH,OAAzB","sourcesContent":["\"use strict\";\n\nvar _sliceInstanceProperty = require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\");\n\nvar _Array$from = require(\"@babel/runtime-corejs3/core-js-stable/array/from\");\n\nvar _Symbol = require(\"@babel/runtime-corejs3/core-js-stable/symbol\");\n\nvar _getIteratorMethod = require(\"@babel/runtime-corejs3/core-js/get-iterator-method\");\n\nvar _Array$isArray = require(\"@babel/runtime-corejs3/core-js-stable/array/is-array\");\n\nvar _getIterator = require(\"@babel/runtime-corejs3/core-js/get-iterator\");\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = void 0;\n\nvar _slicedToArray2 = _interopRequireDefault(require(\"@babel/runtime-corejs3/helpers/slicedToArray\"));\n\nvar _forEach = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/for-each\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) { var it; if (typeof _Symbol === \"undefined\" || _getIteratorMethod(o) == null) { if (_Array$isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = _getIterator(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it[\"return\"] != null) it[\"return\"](); } finally { if (didErr) throw err; } } }; }\n\nfunction _unsupportedIterableToArray(o, minLen) { var _context4; if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = _sliceInstanceProperty(_context4 = Object.prototype.toString.call(o)).call(_context4, 8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return _Array$from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\n/*!\n * XRegExp Unicode Base 5.0.2\n * <xregexp.com>\n * Steven Levithan (c) 2008-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  /**\n   * Adds base support for Unicode matching:\n   * - Adds syntax `\\p{..}` for matching Unicode tokens. Tokens can be inverted using `\\P{..}` or\n   *   `\\p{^..}`. Token names ignore case, spaces, hyphens, and underscores. You can omit the\n   *   braces for token names that are a single letter (e.g. `\\pL` or `PL`).\n   * - Adds flag A (astral), which enables 21-bit Unicode support.\n   * - Adds the `XRegExp.addUnicodeData` method used by other addons to provide character data.\n   *\n   * Unicode Base relies on externally provided Unicode character data. Official addons are\n   * available to provide data for Unicode categories, scripts, and properties.\n   *\n   * @requires XRegExp\n   */\n  // ==--------------------------==\n  // Private stuff\n  // ==--------------------------==\n  // Storage for Unicode data\n  var unicode = {};\n  var unicodeTypes = {}; // Reuse utils\n\n  var dec = XRegExp._dec;\n  var hex = XRegExp._hex;\n  var pad4 = XRegExp._pad4; // Generates a token lookup name: lowercase, with hyphens, spaces, and underscores removed\n\n  function normalize(name) {\n    return name.replace(/[- _]+/g, '').toLowerCase();\n  } // Gets the decimal code of a literal code unit, \\xHH, \\uHHHH, or a backslash-escaped literal\n\n\n  function charCode(chr) {\n    var esc = /^\\\\[xu](.+)/.exec(chr);\n    return esc ? dec(esc[1]) : chr.charCodeAt(chr[0] === '\\\\' ? 1 : 0);\n  } // Inverts a list of ordered BMP characters and ranges\n\n\n  function invertBmp(range) {\n    var output = '';\n    var lastEnd = -1;\n    (0, _forEach[\"default\"])(XRegExp).call(XRegExp, range, /(\\\\x..|\\\\u....|\\\\?[\\s\\S])(?:-(\\\\x..|\\\\u....|\\\\?[\\s\\S]))?/, function (m) {\n      var start = charCode(m[1]);\n\n      if (start > lastEnd + 1) {\n        output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n        if (start > lastEnd + 2) {\n          output += \"-\\\\u\".concat(pad4(hex(start - 1)));\n        }\n      }\n\n      lastEnd = charCode(m[2] || m[1]);\n    });\n\n    if (lastEnd < 0xFFFF) {\n      output += \"\\\\u\".concat(pad4(hex(lastEnd + 1)));\n\n      if (lastEnd < 0xFFFE) {\n        output += '-\\\\uFFFF';\n      }\n    }\n\n    return output;\n  } // Generates an inverted BMP range on first use\n\n\n  function cacheInvertedBmp(slug) {\n    var prop = 'b!';\n    return unicode[slug][prop] || (unicode[slug][prop] = invertBmp(unicode[slug].bmp));\n  } // Combines and optionally negates BMP and astral data\n\n\n  function buildAstral(slug, isNegated) {\n    var item = unicode[slug];\n    var combined = '';\n\n    if (item.bmp && !item.isBmpLast) {\n      var _context;\n\n      combined = (0, _concat[\"default\"])(_context = \"[\".concat(item.bmp, \"]\")).call(_context, item.astral ? '|' : '');\n    }\n\n    if (item.astral) {\n      combined += item.astral;\n    }\n\n    if (item.isBmpLast && item.bmp) {\n      var _context2;\n\n      combined += (0, _concat[\"default\"])(_context2 = \"\".concat(item.astral ? '|' : '', \"[\")).call(_context2, item.bmp, \"]\");\n    } // Astral Unicode tokens always match a code point, never a code unit\n\n\n    return isNegated ? \"(?:(?!\".concat(combined, \")(?:[\\uD800-\\uDBFF][\\uDC00-\\uDFFF]|[\\0-\\uFFFF]))\") : \"(?:\".concat(combined, \")\");\n  } // Builds a complete astral pattern on first use\n\n\n  function cacheAstral(slug, isNegated) {\n    var prop = isNegated ? 'a!' : 'a=';\n    return unicode[slug][prop] || (unicode[slug][prop] = buildAstral(slug, isNegated));\n  } // ==--------------------------==\n  // Core functionality\n  // ==--------------------------==\n\n  /*\n   * Add astral mode (flag A) and Unicode token syntax: `\\p{..}`, `\\P{..}`, `\\p{^..}`, `\\pC`.\n   */\n\n\n  XRegExp.addToken( // Use `*` instead of `+` to avoid capturing `^` as the token name in `\\p{^}`\n  /\\\\([pP])(?:{(\\^?)(?:(\\w+)=)?([^}]*)}|([A-Za-z]))/, function (match, scope, flags) {\n    var ERR_DOUBLE_NEG = 'Invalid double negation ';\n    var ERR_UNKNOWN_NAME = 'Unknown Unicode token ';\n    var ERR_UNKNOWN_REF = 'Unicode token missing data ';\n    var ERR_ASTRAL_ONLY = 'Astral mode required for Unicode token ';\n    var ERR_ASTRAL_IN_CLASS = 'Astral mode does not support Unicode tokens within character classes';\n\n    var _match = (0, _slicedToArray2[\"default\"])(match, 6),\n        fullToken = _match[0],\n        pPrefix = _match[1],\n        caretNegation = _match[2],\n        typePrefix = _match[3],\n        tokenName = _match[4],\n        tokenSingleCharName = _match[5]; // Negated via \\P{..} or \\p{^..}\n\n\n    var isNegated = pPrefix === 'P' || !!caretNegation; // Switch from BMP (0-FFFF) to astral (0-10FFFF) mode via flag A\n\n    var isAstralMode = (0, _indexOf[\"default\"])(flags).call(flags, 'A') !== -1; // Token lookup name. Check `tokenSingleCharName` first to avoid passing `undefined`\n    // via `\\p{}`\n\n    var slug = normalize(tokenSingleCharName || tokenName); // Token data object\n\n    var item = unicode[slug];\n\n    if (pPrefix === 'P' && caretNegation) {\n      throw new SyntaxError(ERR_DOUBLE_NEG + fullToken);\n    }\n\n    if (!unicode.hasOwnProperty(slug)) {\n      throw new SyntaxError(ERR_UNKNOWN_NAME + fullToken);\n    }\n\n    if (typePrefix) {\n      if (!(unicodeTypes[typePrefix] && unicodeTypes[typePrefix][slug])) {\n        throw new SyntaxError(ERR_UNKNOWN_NAME + fullToken);\n      }\n    } // Switch to the negated form of the referenced Unicode token\n\n\n    if (item.inverseOf) {\n      slug = normalize(item.inverseOf);\n\n      if (!unicode.hasOwnProperty(slug)) {\n        var _context3;\n\n        throw new ReferenceError((0, _concat[\"default\"])(_context3 = \"\".concat(ERR_UNKNOWN_REF + fullToken, \" -> \")).call(_context3, item.inverseOf));\n      }\n\n      item = unicode[slug];\n      isNegated = !isNegated;\n    }\n\n    if (!(item.bmp || isAstralMode)) {\n      throw new SyntaxError(ERR_ASTRAL_ONLY + fullToken);\n    }\n\n    if (isAstralMode) {\n      if (scope === 'class') {\n        throw new SyntaxError(ERR_ASTRAL_IN_CLASS);\n      }\n\n      return cacheAstral(slug, isNegated);\n    }\n\n    return scope === 'class' ? isNegated ? cacheInvertedBmp(slug) : item.bmp : \"\".concat((isNegated ? '[^' : '[') + item.bmp, \"]\");\n  }, {\n    scope: 'all',\n    optionalFlags: 'A',\n    leadChar: '\\\\'\n  });\n  /**\n   * Adds to the list of Unicode tokens that XRegExp regexes can match via `\\p` or `\\P`.\n   *\n   * @memberOf XRegExp\n   * @param {Array} data Objects with named character ranges. Each object may have properties\n   *   `name`, `alias`, `isBmpLast`, `inverseOf`, `bmp`, and `astral`. All but `name` are\n   *   optional, although one of `bmp` or `astral` is required (unless `inverseOf` is set). If\n   *   `astral` is absent, the `bmp` data is used for BMP and astral modes. If `bmp` is absent,\n   *   the name errors in BMP mode but works in astral mode. If both `bmp` and `astral` are\n   *   provided, the `bmp` data only is used in BMP mode, and the combination of `bmp` and\n   *   `astral` data is used in astral mode. `isBmpLast` is needed when a token matches orphan\n   *   high surrogates *and* uses surrogate pairs to match astral code points. The `bmp` and\n   *   `astral` data should be a combination of literal characters and `\\xHH` or `\\uHHHH` escape\n   *   sequences, with hyphens to create ranges. Any regex metacharacters in the data should be\n   *   escaped, apart from range-creating hyphens. The `astral` data can additionally use\n   *   character classes and alternation, and should use surrogate pairs to represent astral code\n   *   points. `inverseOf` can be used to avoid duplicating character data if a Unicode token is\n   *   defined as the exact inverse of another token.\n   * @param {String} [typePrefix] Enables optionally using this type as a prefix for all of the\n   *   provided Unicode tokens, e.g. if given `'Type'`, then `\\p{TokenName}` can also be written\n   *   as `\\p{Type=TokenName}`.\n   * @example\n   *\n   * // Basic use\n   * XRegExp.addUnicodeData([{\n   *   name: 'XDigit',\n   *   alias: 'Hexadecimal',\n   *   bmp: '0-9A-Fa-f'\n   * }]);\n   * XRegExp('\\\\p{XDigit}:\\\\p{Hexadecimal}+').test('0:3D'); // -> true\n   */\n\n  XRegExp.addUnicodeData = function (data, typePrefix) {\n    var ERR_NO_NAME = 'Unicode token requires name';\n    var ERR_NO_DATA = 'Unicode token has no character data ';\n\n    if (typePrefix) {\n      // Case sensitive to match ES2018\n      unicodeTypes[typePrefix] = {};\n    }\n\n    var _iterator = _createForOfIteratorHelper(data),\n        _step;\n\n    try {\n      for (_iterator.s(); !(_step = _iterator.n()).done;) {\n        var item = _step.value;\n\n        if (!item.name) {\n          throw new Error(ERR_NO_NAME);\n        }\n\n        if (!(item.inverseOf || item.bmp || item.astral)) {\n          throw new Error(ERR_NO_DATA + item.name);\n        }\n\n        var normalizedName = normalize(item.name);\n        unicode[normalizedName] = item;\n\n        if (typePrefix) {\n          unicodeTypes[typePrefix][normalizedName] = true;\n        }\n\n        if (item.alias) {\n          var normalizedAlias = normalize(item.alias);\n          unicode[normalizedAlias] = item;\n\n          if (typePrefix) {\n            unicodeTypes[typePrefix][normalizedAlias] = true;\n          }\n        }\n      } // Reset the pattern cache used by the `XRegExp` constructor, since the same pattern and\n      // flags might now produce different results\n\n    } catch (err) {\n      _iterator.e(err);\n    } finally {\n      _iterator.f();\n    }\n\n    XRegExp.cache.flush('patterns');\n  };\n  /**\n   * @ignore\n   *\n   * Return a reference to the internal Unicode definition structure for the given Unicode\n   * Property if the given name is a legal Unicode Property for use in XRegExp `\\p` or `\\P` regex\n   * constructs.\n   *\n   * @memberOf XRegExp\n   * @param {String} name Name by which the Unicode Property may be recognized (case-insensitive),\n   *   e.g. `'N'` or `'Number'`. The given name is matched against all registered Unicode\n   *   Properties and Property Aliases.\n   * @returns {Object} Reference to definition structure when the name matches a Unicode Property.\n   *\n   * @note\n   * For more info on Unicode Properties, see also http://unicode.org/reports/tr18/#Categories.\n   *\n   * @note\n   * This method is *not* part of the officially documented API and may change or be removed in\n   * the future. It is meant for userland code that wishes to reuse the (large) internal Unicode\n   * structures set up by XRegExp.\n   */\n\n\n  XRegExp._getUnicodeProperty = function (name) {\n    var slug = normalize(name);\n    return unicode[slug];\n  };\n};\n\nexports[\"default\"] = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}