{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = void 0;\n\nvar _reduce = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/reduce\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n/*!\n * XRegExp.build 5.0.2\n * <xregexp.com>\n * Steven Levithan (c) 2012-present MIT License\n */\n\n\nvar _default = function _default(XRegExp) {\n  var REGEX_DATA = 'xregexp';\n  var subParts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  var parts = XRegExp.union([/\\({{([\\w$]+)}}\\)|{{([\\w$]+)}}/, subParts], 'g', {\n    conjunction: 'or'\n  });\n  /**\n   * Strips a leading `^` and trailing unescaped `$`, if both are present.\n   *\n   * @private\n   * @param {String} pattern Pattern to process.\n   * @returns {String} Pattern with edge anchors removed.\n   */\n\n  function deanchor(pattern) {\n    // Allow any number of empty noncapturing groups before/after anchors, because regexes\n    // built/generated by XRegExp sometimes include them\n    var leadingAnchor = /^(?:\\(\\?:\\))*\\^/;\n    var trailingAnchor = /\\$(?:\\(\\?:\\))*$/;\n\n    if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && // Ensure that the trailing `$` isn't escaped\n    trailingAnchor.test(pattern.replace(/\\\\[\\s\\S]/g, ''))) {\n      return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');\n    }\n\n    return pattern;\n  }\n  /**\n   * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.\n   *\n   * @private\n   * @param {String|RegExp} value Value to convert.\n   * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not\n   *   already a regex generated by XRegExp\n   * @returns {RegExp} XRegExp object with XRegExp syntax applied.\n   */\n\n\n  function asXRegExp(value, addFlagX) {\n    var flags = addFlagX ? 'x' : '';\n    return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ? // Don't recompile, to preserve capture names\n    value : // Recompile as XRegExp\n    XRegExp(value.source, flags) : // Compile string as XRegExp\n    XRegExp(value, flags);\n  }\n\n  function interpolate(substitution) {\n    return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);\n  }\n\n  function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {\n    subpatterns[\"subpattern\".concat(subpatternIndex)] = interpolated;\n    return subpatterns;\n  }\n\n  function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {\n    var hasSubpattern = subpatternIndex < rawLiterals.length - 1;\n    return raw + (hasSubpattern ? \"{{subpattern\".concat(subpatternIndex, \"}}\") : '');\n  }\n  /**\n   * Provides tagged template literals that create regexes with XRegExp syntax and flags. The\n   * provided pattern is handled as a raw string, so backslashes don't need to be escaped.\n   *\n   * Interpolation of strings and regexes shares the features of `XRegExp.build`. Interpolated\n   * patterns are treated as atomic units when quantified, interpolated strings have their special\n   * characters escaped, a leading `^` and trailing unescaped `$` are stripped from interpolated\n   * regexes if both are present, and any backreferences within an interpolated regex are\n   * rewritten to work within the overall pattern.\n   *\n   * @memberOf XRegExp\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {Function} Handler for template literals that construct regexes with XRegExp syntax.\n   * @example\n   *\n   * XRegExp.tag()`\\b\\w+\\b`.test('word'); // -> true\n   *\n   * const hours = /1[0-2]|0?[1-9]/;\n   * const minutes = /(?<minutes>[0-5][0-9])/;\n   * const time = XRegExp.tag('x')`\\b ${hours} : ${minutes} \\b`;\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).groups.minutes; // -> '59'\n   *\n   * const backref1 = /(a)\\1/;\n   * const backref2 = /(b)\\1/;\n   * XRegExp.tag()`${backref1}${backref2}`.test('aabb'); // -> true\n   */\n\n\n  XRegExp.tag = function (flags) {\n    return function (literals) {\n      var _context, _context2;\n\n      for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        substitutions[_key - 1] = arguments[_key];\n      }\n\n      var subpatterns = (0, _reduce[\"default\"])(_context = (0, _map[\"default\"])(substitutions).call(substitutions, interpolate)).call(_context, reduceToSubpatternsObject, {});\n      var pattern = (0, _map[\"default\"])(_context2 = literals.raw).call(_context2, embedSubpatternAfter).join('');\n      return XRegExp.build(pattern, subpatterns, flags);\n    };\n  };\n  /**\n   * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in\n   * the outer pattern and provided subpatterns are automatically renumbered to work correctly.\n   * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.\n   *\n   * @memberOf XRegExp\n   * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows\n   *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within\n   *   character classes.\n   * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A\n   *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {RegExp} Regex with interpolated subpatterns.\n   * @example\n   *\n   * const time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\n   *   hours: XRegExp.build('{{h12}} : | {{h24}}', {\n   *     h12: /1[0-2]|0?[1-9]/,\n   *     h24: /2[0-3]|[01][0-9]/\n   *   }, 'x'),\n   *   minutes: /^[0-5][0-9]$/\n   * });\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).groups.minutes; // -> '59'\n   */\n\n\n  XRegExp.build = function (pattern, subs, flags) {\n    flags = flags || ''; // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how\n    // some browsers convert `RegExp('\\n')` to a regex that contains the literal characters `\\`\n    // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.\n\n    var addFlagX = (0, _indexOf[\"default\"])(flags).call(flags, 'x') !== -1;\n    var inlineFlags = /^\\(\\?([\\w$]+)\\)/.exec(pattern); // Add flags within a leading mode modifier to the overall pattern's flags\n\n    if (inlineFlags) {\n      flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);\n    }\n\n    var data = {};\n\n    for (var p in subs) {\n      if (subs.hasOwnProperty(p)) {\n        // Passing to XRegExp enables extended syntax and ensures independent validity,\n        // lest an unescaped `(`, `)`, `[`, or trailing `\\` breaks the `(?:)` wrapper. For\n        // subpatterns provided as native regexes, it dies on octals and adds the property\n        // used to hold extended regex instance data, for simplicity.\n        var sub = asXRegExp(subs[p], addFlagX);\n        data[p] = {\n          // Deanchoring allows embedding independently useful anchored regexes. If you\n          // really need to keep your anchors, double them (i.e., `^^...$$`).\n          pattern: deanchor(sub.source),\n          names: sub[REGEX_DATA].captureNames || []\n        };\n      }\n    } // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;\n    // helps keep this simple. Named captures will be put back.\n\n\n    var patternAsRegex = asXRegExp(pattern, addFlagX); // 'Caps' is short for 'captures'\n\n    var numCaps = 0;\n    var numPriorCaps;\n    var numOuterCaps = 0;\n    var outerCapsMap = [0];\n    var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];\n    var output = patternAsRegex.source.replace(parts, function ($0, $1, $2, $3, $4) {\n      var subName = $1 || $2;\n      var capName;\n      var intro;\n      var localCapIndex; // Named subpattern\n\n      if (subName) {\n        var _context3;\n\n        if (!data.hasOwnProperty(subName)) {\n          throw new ReferenceError(\"Undefined property \".concat($0));\n        } // Named subpattern was wrapped in a capturing group\n\n\n        if ($1) {\n          capName = outerCapNames[numOuterCaps];\n          outerCapsMap[++numOuterCaps] = ++numCaps; // If it's a named group, preserve the name. Otherwise, use the subpattern name\n          // as the capture name\n\n          intro = \"(?<\".concat(capName || subName, \">\");\n        } else {\n          intro = '(?:';\n        }\n\n        numPriorCaps = numCaps;\n        var rewrittenSubpattern = data[subName].pattern.replace(subParts, function (match, paren, backref) {\n          // Capturing group\n          if (paren) {\n            capName = data[subName].names[numCaps - numPriorCaps];\n            ++numCaps; // If the current capture has a name, preserve the name\n\n            if (capName) {\n              return \"(?<\".concat(capName, \">\");\n            } // Backreference\n\n          } else if (backref) {\n            localCapIndex = +backref - 1; // Rewrite the backreference\n\n            return data[subName].names[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n            \"\\\\k<\".concat(data[subName].names[localCapIndex], \">\") : \"\\\\\".concat(+backref + numPriorCaps);\n          }\n\n          return match;\n        });\n        return (0, _concat[\"default\"])(_context3 = \"\".concat(intro)).call(_context3, rewrittenSubpattern, \")\");\n      } // Capturing group\n\n\n      if ($3) {\n        capName = outerCapNames[numOuterCaps];\n        outerCapsMap[++numOuterCaps] = ++numCaps; // If the current capture has a name, preserve the name\n\n        if (capName) {\n          return \"(?<\".concat(capName, \">\");\n        } // Backreference\n\n      } else if ($4) {\n        localCapIndex = +$4 - 1; // Rewrite the backreference\n\n        return outerCapNames[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n        \"\\\\k<\".concat(outerCapNames[localCapIndex], \">\") : \"\\\\\".concat(outerCapsMap[+$4]);\n      }\n\n      return $0;\n    });\n    return XRegExp(output, flags);\n  };\n};\n\nexports[\"default\"] = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["E:/AcademicAdvisingSystem/client/node_modules/xregexp/lib/addons/build.js"],"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","_reduce","_map","_indexOf","_concat","_default","XRegExp","REGEX_DATA","subParts","parts","union","conjunction","deanchor","pattern","leadingAnchor","trailingAnchor","test","replace","asXRegExp","addFlagX","flags","isRegExp","captureNames","source","interpolate","substitution","RegExp","escape","reduceToSubpatternsObject","subpatterns","interpolated","subpatternIndex","concat","embedSubpatternAfter","raw","rawLiterals","hasSubpattern","length","tag","literals","_context","_context2","_len","arguments","substitutions","Array","_key","call","join","build","subs","inlineFlags","exec","_clipDuplicates","data","p","hasOwnProperty","sub","names","patternAsRegex","numCaps","numPriorCaps","numOuterCaps","outerCapsMap","outerCapNames","output","$0","$1","$2","$3","$4","subName","capName","intro","localCapIndex","_context3","ReferenceError","rewrittenSubpattern","match","paren","backref","module","default"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8DAAD,CAApC;;AAEA,IAAIC,sBAAsB,GAAGD,OAAO,CAAC,sDAAD,CAApC;;AAEAD,sBAAsB,CAACG,OAAD,EAAU,YAAV,EAAwB;AAC5CC,EAAAA,KAAK,EAAE;AADqC,CAAxB,CAAtB;;AAIAD,OAAO,CAAC,SAAD,CAAP,GAAqB,KAAK,CAA1B;;AAEA,IAAIE,OAAO,GAAGH,sBAAsB,CAACD,OAAO,CAAC,uDAAD,CAAR,CAApC;;AAEA,IAAIK,IAAI,GAAGJ,sBAAsB,CAACD,OAAO,CAAC,oDAAD,CAAR,CAAjC;;AAEA,IAAIM,QAAQ,GAAGL,sBAAsB,CAACD,OAAO,CAAC,yDAAD,CAAR,CAArC;;AAEA,IAAIO,OAAO,GAAGN,sBAAsB,CAACD,OAAO,CAAC,uDAAD,CAAR,CAApC;AAEA;AACA;AACA;AACA;AACA;;;AACA,IAAIQ,QAAQ,GAAG,SAASA,QAAT,CAAkBC,OAAlB,EAA2B;AACxC,MAAIC,UAAU,GAAG,SAAjB;AACA,MAAIC,QAAQ,GAAG,6DAAf;AACA,MAAIC,KAAK,GAAGH,OAAO,CAACI,KAAR,CAAc,CAAC,+BAAD,EAAkCF,QAAlC,CAAd,EAA2D,GAA3D,EAAgE;AAC1EG,IAAAA,WAAW,EAAE;AAD6D,GAAhE,CAAZ;AAGA;AACF;AACA;AACA;AACA;AACA;AACA;;AAEE,WAASC,QAAT,CAAkBC,OAAlB,EAA2B;AACzB;AACA;AACA,QAAIC,aAAa,GAAG,iBAApB;AACA,QAAIC,cAAc,GAAG,iBAArB;;AAEA,QAAID,aAAa,CAACE,IAAd,CAAmBH,OAAnB,KAA+BE,cAAc,CAACC,IAAf,CAAoBH,OAApB,CAA/B,IAA+D;AACnEE,IAAAA,cAAc,CAACC,IAAf,CAAoBH,OAAO,CAACI,OAAR,CAAgB,WAAhB,EAA6B,EAA7B,CAApB,CADA,EACuD;AACrD,aAAOJ,OAAO,CAACI,OAAR,CAAgBH,aAAhB,EAA+B,EAA/B,EAAmCG,OAAnC,CAA2CF,cAA3C,EAA2D,EAA3D,CAAP;AACD;;AAED,WAAOF,OAAP;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGE,WAASK,SAAT,CAAmBlB,KAAnB,EAA0BmB,QAA1B,EAAoC;AAClC,QAAIC,KAAK,GAAGD,QAAQ,GAAG,GAAH,GAAS,EAA7B;AACA,WAAOb,OAAO,CAACe,QAAR,CAAiBrB,KAAjB,IAA0BA,KAAK,CAACO,UAAD,CAAL,IAAqBP,KAAK,CAACO,UAAD,CAAL,CAAkBe,YAAvC,GAAsD;AACvFtB,IAAAA,KADiC,GACzB;AACRM,IAAAA,OAAO,CAACN,KAAK,CAACuB,MAAP,EAAeH,KAAf,CAFA,GAEwB;AAC/Bd,IAAAA,OAAO,CAACN,KAAD,EAAQoB,KAAR,CAHP;AAID;;AAED,WAASI,WAAT,CAAqBC,YAArB,EAAmC;AACjC,WAAOA,YAAY,YAAYC,MAAxB,GAAiCD,YAAjC,GAAgDnB,OAAO,CAACqB,MAAR,CAAeF,YAAf,CAAvD;AACD;;AAED,WAASG,yBAAT,CAAmCC,WAAnC,EAAgDC,YAAhD,EAA8DC,eAA9D,EAA+E;AAC7EF,IAAAA,WAAW,CAAC,aAAaG,MAAb,CAAoBD,eAApB,CAAD,CAAX,GAAoDD,YAApD;AACA,WAAOD,WAAP;AACD;;AAED,WAASI,oBAAT,CAA8BC,GAA9B,EAAmCH,eAAnC,EAAoDI,WAApD,EAAiE;AAC/D,QAAIC,aAAa,GAAGL,eAAe,GAAGI,WAAW,CAACE,MAAZ,GAAqB,CAA3D;AACA,WAAOH,GAAG,IAAIE,aAAa,GAAG,eAAeJ,MAAf,CAAsBD,eAAtB,EAAuC,IAAvC,CAAH,GAAkD,EAAnE,CAAV;AACD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGEzB,EAAAA,OAAO,CAACgC,GAAR,GAAc,UAAUlB,KAAV,EAAiB;AAC7B,WAAO,UAAUmB,QAAV,EAAoB;AACzB,UAAIC,QAAJ,EAAcC,SAAd;;AAEA,WAAK,IAAIC,IAAI,GAAGC,SAAS,CAACN,MAArB,EAA6BO,aAAa,GAAG,IAAIC,KAAJ,CAAUH,IAAI,GAAG,CAAP,GAAWA,IAAI,GAAG,CAAlB,GAAsB,CAAhC,CAA7C,EAAiFI,IAAI,GAAG,CAA7F,EAAgGA,IAAI,GAAGJ,IAAvG,EAA6GI,IAAI,EAAjH,EAAqH;AACnHF,QAAAA,aAAa,CAACE,IAAI,GAAG,CAAR,CAAb,GAA0BH,SAAS,CAACG,IAAD,CAAnC;AACD;;AAED,UAAIjB,WAAW,GAAG,CAAC,GAAG5B,OAAO,CAAC,SAAD,CAAX,EAAwBuC,QAAQ,GAAG,CAAC,GAAGtC,IAAI,CAAC,SAAD,CAAR,EAAqB0C,aAArB,EAAoCG,IAApC,CAAyCH,aAAzC,EAAwDpB,WAAxD,CAAnC,EAAyGuB,IAAzG,CAA8GP,QAA9G,EAAwHZ,yBAAxH,EAAmJ,EAAnJ,CAAlB;AACA,UAAIf,OAAO,GAAG,CAAC,GAAGX,IAAI,CAAC,SAAD,CAAR,EAAqBuC,SAAS,GAAGF,QAAQ,CAACL,GAA1C,EAA+Ca,IAA/C,CAAoDN,SAApD,EAA+DR,oBAA/D,EAAqFe,IAArF,CAA0F,EAA1F,CAAd;AACA,aAAO1C,OAAO,CAAC2C,KAAR,CAAcpC,OAAd,EAAuBgB,WAAvB,EAAoCT,KAApC,CAAP;AACD,KAVD;AAWD,GAZD;AAaA;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGEd,EAAAA,OAAO,CAAC2C,KAAR,GAAgB,UAAUpC,OAAV,EAAmBqC,IAAnB,EAAyB9B,KAAzB,EAAgC;AAC9CA,IAAAA,KAAK,GAAGA,KAAK,IAAI,EAAjB,CAD8C,CACzB;AACrB;AACA;;AAEA,QAAID,QAAQ,GAAG,CAAC,GAAGhB,QAAQ,CAAC,SAAD,CAAZ,EAAyBiB,KAAzB,EAAgC2B,IAAhC,CAAqC3B,KAArC,EAA4C,GAA5C,MAAqD,CAAC,CAArE;AACA,QAAI+B,WAAW,GAAG,kBAAkBC,IAAlB,CAAuBvC,OAAvB,CAAlB,CAN8C,CAMK;;AAEnD,QAAIsC,WAAJ,EAAiB;AACf/B,MAAAA,KAAK,GAAGd,OAAO,CAAC+C,eAAR,CAAwBjC,KAAK,GAAG+B,WAAW,CAAC,CAAD,CAA3C,CAAR;AACD;;AAED,QAAIG,IAAI,GAAG,EAAX;;AAEA,SAAK,IAAIC,CAAT,IAAcL,IAAd,EAAoB;AAClB,UAAIA,IAAI,CAACM,cAAL,CAAoBD,CAApB,CAAJ,EAA4B;AAC1B;AACA;AACA;AACA;AACA,YAAIE,GAAG,GAAGvC,SAAS,CAACgC,IAAI,CAACK,CAAD,CAAL,EAAUpC,QAAV,CAAnB;AACAmC,QAAAA,IAAI,CAACC,CAAD,CAAJ,GAAU;AACR;AACA;AACA1C,UAAAA,OAAO,EAAED,QAAQ,CAAC6C,GAAG,CAAClC,MAAL,CAHT;AAIRmC,UAAAA,KAAK,EAAED,GAAG,CAAClD,UAAD,CAAH,CAAgBe,YAAhB,IAAgC;AAJ/B,SAAV;AAMD;AACF,KA5B6C,CA4B5C;AACF;;;AAGA,QAAIqC,cAAc,GAAGzC,SAAS,CAACL,OAAD,EAAUM,QAAV,CAA9B,CAhC8C,CAgCK;;AAEnD,QAAIyC,OAAO,GAAG,CAAd;AACA,QAAIC,YAAJ;AACA,QAAIC,YAAY,GAAG,CAAnB;AACA,QAAIC,YAAY,GAAG,CAAC,CAAD,CAAnB;AACA,QAAIC,aAAa,GAAGL,cAAc,CAACpD,UAAD,CAAd,CAA2Be,YAA3B,IAA2C,EAA/D;AACA,QAAI2C,MAAM,GAAGN,cAAc,CAACpC,MAAf,CAAsBN,OAAtB,CAA8BR,KAA9B,EAAqC,UAAUyD,EAAV,EAAcC,EAAd,EAAkBC,EAAlB,EAAsBC,EAAtB,EAA0BC,EAA1B,EAA8B;AAC9E,UAAIC,OAAO,GAAGJ,EAAE,IAAIC,EAApB;AACA,UAAII,OAAJ;AACA,UAAIC,KAAJ;AACA,UAAIC,aAAJ,CAJ8E,CAI3D;;AAEnB,UAAIH,OAAJ,EAAa;AACX,YAAII,SAAJ;;AAEA,YAAI,CAACrB,IAAI,CAACE,cAAL,CAAoBe,OAApB,CAAL,EAAmC;AACjC,gBAAM,IAAIK,cAAJ,CAAmB,sBAAsB5C,MAAtB,CAA6BkC,EAA7B,CAAnB,CAAN;AACD,SALU,CAKT;;;AAGF,YAAIC,EAAJ,EAAQ;AACNK,UAAAA,OAAO,GAAGR,aAAa,CAACF,YAAD,CAAvB;AACAC,UAAAA,YAAY,CAAC,EAAED,YAAH,CAAZ,GAA+B,EAAEF,OAAjC,CAFM,CAEoC;AAC1C;;AAEAa,UAAAA,KAAK,GAAG,MAAMzC,MAAN,CAAawC,OAAO,IAAID,OAAxB,EAAiC,GAAjC,CAAR;AACD,SAND,MAMO;AACLE,UAAAA,KAAK,GAAG,KAAR;AACD;;AAEDZ,QAAAA,YAAY,GAAGD,OAAf;AACA,YAAIiB,mBAAmB,GAAGvB,IAAI,CAACiB,OAAD,CAAJ,CAAc1D,OAAd,CAAsBI,OAAtB,CAA8BT,QAA9B,EAAwC,UAAUsE,KAAV,EAAiBC,KAAjB,EAAwBC,OAAxB,EAAiC;AACjG;AACA,cAAID,KAAJ,EAAW;AACTP,YAAAA,OAAO,GAAGlB,IAAI,CAACiB,OAAD,CAAJ,CAAcb,KAAd,CAAoBE,OAAO,GAAGC,YAA9B,CAAV;AACA,cAAED,OAAF,CAFS,CAEE;;AAEX,gBAAIY,OAAJ,EAAa;AACX,qBAAO,MAAMxC,MAAN,CAAawC,OAAb,EAAsB,GAAtB,CAAP;AACD,aANQ,CAMP;;AAEH,WARD,MAQO,IAAIQ,OAAJ,EAAa;AAClBN,YAAAA,aAAa,GAAG,CAACM,OAAD,GAAW,CAA3B,CADkB,CACY;;AAE9B,mBAAO1B,IAAI,CAACiB,OAAD,CAAJ,CAAcb,KAAd,CAAoBgB,aAApB,IAAqC;AAC5C,mBAAO1C,MAAP,CAAcsB,IAAI,CAACiB,OAAD,CAAJ,CAAcb,KAAd,CAAoBgB,aAApB,CAAd,EAAkD,GAAlD,CADO,GACkD,KAAK1C,MAAL,CAAY,CAACgD,OAAD,GAAWnB,YAAvB,CADzD;AAED;;AAED,iBAAOiB,KAAP;AACD,SAlByB,CAA1B;AAmBA,eAAO,CAAC,GAAG1E,OAAO,CAAC,SAAD,CAAX,EAAwBuE,SAAS,GAAG,GAAG3C,MAAH,CAAUyC,KAAV,CAApC,EAAsD1B,IAAtD,CAA2D4B,SAA3D,EAAsEE,mBAAtE,EAA2F,GAA3F,CAAP;AACD,OA7C6E,CA6C5E;;;AAGF,UAAIR,EAAJ,EAAQ;AACNG,QAAAA,OAAO,GAAGR,aAAa,CAACF,YAAD,CAAvB;AACAC,QAAAA,YAAY,CAAC,EAAED,YAAH,CAAZ,GAA+B,EAAEF,OAAjC,CAFM,CAEoC;;AAE1C,YAAIY,OAAJ,EAAa;AACX,iBAAO,MAAMxC,MAAN,CAAawC,OAAb,EAAsB,GAAtB,CAAP;AACD,SANK,CAMJ;;AAEH,OARD,MAQO,IAAIF,EAAJ,EAAQ;AACbI,QAAAA,aAAa,GAAG,CAACJ,EAAD,GAAM,CAAtB,CADa,CACY;;AAEzB,eAAON,aAAa,CAACU,aAAD,CAAb,GAA+B;AACtC,eAAO1C,MAAP,CAAcgC,aAAa,CAACU,aAAD,CAA3B,EAA4C,GAA5C,CADO,GAC4C,KAAK1C,MAAL,CAAY+B,YAAY,CAAC,CAACO,EAAF,CAAxB,CADnD;AAED;;AAED,aAAOJ,EAAP;AACD,KAhEY,CAAb;AAiEA,WAAO5D,OAAO,CAAC2D,MAAD,EAAS7C,KAAT,CAAd;AACD,GAzGD;AA0GD,CA1OD;;AA4OArB,OAAO,CAAC,SAAD,CAAP,GAAqBM,QAArB;AACA4E,MAAM,CAAClF,OAAP,GAAiBA,OAAO,CAACmF,OAAzB","sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = void 0;\n\nvar _reduce = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/reduce\"));\n\nvar _map = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/map\"));\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\n/*!\n * XRegExp.build 5.0.2\n * <xregexp.com>\n * Steven Levithan (c) 2012-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  var REGEX_DATA = 'xregexp';\n  var subParts = /(\\()(?!\\?)|\\\\([1-9]\\d*)|\\\\[\\s\\S]|\\[(?:[^\\\\\\]]|\\\\[\\s\\S])*\\]/g;\n  var parts = XRegExp.union([/\\({{([\\w$]+)}}\\)|{{([\\w$]+)}}/, subParts], 'g', {\n    conjunction: 'or'\n  });\n  /**\n   * Strips a leading `^` and trailing unescaped `$`, if both are present.\n   *\n   * @private\n   * @param {String} pattern Pattern to process.\n   * @returns {String} Pattern with edge anchors removed.\n   */\n\n  function deanchor(pattern) {\n    // Allow any number of empty noncapturing groups before/after anchors, because regexes\n    // built/generated by XRegExp sometimes include them\n    var leadingAnchor = /^(?:\\(\\?:\\))*\\^/;\n    var trailingAnchor = /\\$(?:\\(\\?:\\))*$/;\n\n    if (leadingAnchor.test(pattern) && trailingAnchor.test(pattern) && // Ensure that the trailing `$` isn't escaped\n    trailingAnchor.test(pattern.replace(/\\\\[\\s\\S]/g, ''))) {\n      return pattern.replace(leadingAnchor, '').replace(trailingAnchor, '');\n    }\n\n    return pattern;\n  }\n  /**\n   * Converts the provided value to an XRegExp. Native RegExp flags are not preserved.\n   *\n   * @private\n   * @param {String|RegExp} value Value to convert.\n   * @param {Boolean} [addFlagX] Whether to apply the `x` flag in cases when `value` is not\n   *   already a regex generated by XRegExp\n   * @returns {RegExp} XRegExp object with XRegExp syntax applied.\n   */\n\n\n  function asXRegExp(value, addFlagX) {\n    var flags = addFlagX ? 'x' : '';\n    return XRegExp.isRegExp(value) ? value[REGEX_DATA] && value[REGEX_DATA].captureNames ? // Don't recompile, to preserve capture names\n    value : // Recompile as XRegExp\n    XRegExp(value.source, flags) : // Compile string as XRegExp\n    XRegExp(value, flags);\n  }\n\n  function interpolate(substitution) {\n    return substitution instanceof RegExp ? substitution : XRegExp.escape(substitution);\n  }\n\n  function reduceToSubpatternsObject(subpatterns, interpolated, subpatternIndex) {\n    subpatterns[\"subpattern\".concat(subpatternIndex)] = interpolated;\n    return subpatterns;\n  }\n\n  function embedSubpatternAfter(raw, subpatternIndex, rawLiterals) {\n    var hasSubpattern = subpatternIndex < rawLiterals.length - 1;\n    return raw + (hasSubpattern ? \"{{subpattern\".concat(subpatternIndex, \"}}\") : '');\n  }\n  /**\n   * Provides tagged template literals that create regexes with XRegExp syntax and flags. The\n   * provided pattern is handled as a raw string, so backslashes don't need to be escaped.\n   *\n   * Interpolation of strings and regexes shares the features of `XRegExp.build`. Interpolated\n   * patterns are treated as atomic units when quantified, interpolated strings have their special\n   * characters escaped, a leading `^` and trailing unescaped `$` are stripped from interpolated\n   * regexes if both are present, and any backreferences within an interpolated regex are\n   * rewritten to work within the overall pattern.\n   *\n   * @memberOf XRegExp\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {Function} Handler for template literals that construct regexes with XRegExp syntax.\n   * @example\n   *\n   * XRegExp.tag()`\\b\\w+\\b`.test('word'); // -> true\n   *\n   * const hours = /1[0-2]|0?[1-9]/;\n   * const minutes = /(?<minutes>[0-5][0-9])/;\n   * const time = XRegExp.tag('x')`\\b ${hours} : ${minutes} \\b`;\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).groups.minutes; // -> '59'\n   *\n   * const backref1 = /(a)\\1/;\n   * const backref2 = /(b)\\1/;\n   * XRegExp.tag()`${backref1}${backref2}`.test('aabb'); // -> true\n   */\n\n\n  XRegExp.tag = function (flags) {\n    return function (literals) {\n      var _context, _context2;\n\n      for (var _len = arguments.length, substitutions = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        substitutions[_key - 1] = arguments[_key];\n      }\n\n      var subpatterns = (0, _reduce[\"default\"])(_context = (0, _map[\"default\"])(substitutions).call(substitutions, interpolate)).call(_context, reduceToSubpatternsObject, {});\n      var pattern = (0, _map[\"default\"])(_context2 = literals.raw).call(_context2, embedSubpatternAfter).join('');\n      return XRegExp.build(pattern, subpatterns, flags);\n    };\n  };\n  /**\n   * Builds regexes using named subpatterns, for readability and pattern reuse. Backreferences in\n   * the outer pattern and provided subpatterns are automatically renumbered to work correctly.\n   * Native flags used by provided subpatterns are ignored in favor of the `flags` argument.\n   *\n   * @memberOf XRegExp\n   * @param {String} pattern XRegExp pattern using `{{name}}` for embedded subpatterns. Allows\n   *   `({{name}})` as shorthand for `(?<name>{{name}})`. Patterns cannot be embedded within\n   *   character classes.\n   * @param {Object} subs Lookup object for named subpatterns. Values can be strings or regexes. A\n   *   leading `^` and trailing unescaped `$` are stripped from subpatterns, if both are present.\n   * @param {String} [flags] Any combination of XRegExp flags.\n   * @returns {RegExp} Regex with interpolated subpatterns.\n   * @example\n   *\n   * const time = XRegExp.build('(?x)^ {{hours}} ({{minutes}}) $', {\n   *   hours: XRegExp.build('{{h12}} : | {{h24}}', {\n   *     h12: /1[0-2]|0?[1-9]/,\n   *     h24: /2[0-3]|[01][0-9]/\n   *   }, 'x'),\n   *   minutes: /^[0-5][0-9]$/\n   * });\n   * time.test('10:59'); // -> true\n   * XRegExp.exec('10:59', time).groups.minutes; // -> '59'\n   */\n\n\n  XRegExp.build = function (pattern, subs, flags) {\n    flags = flags || ''; // Used with `asXRegExp` calls for `pattern` and subpatterns in `subs`, to work around how\n    // some browsers convert `RegExp('\\n')` to a regex that contains the literal characters `\\`\n    // and `n`. See more details at <https://github.com/slevithan/xregexp/pull/163>.\n\n    var addFlagX = (0, _indexOf[\"default\"])(flags).call(flags, 'x') !== -1;\n    var inlineFlags = /^\\(\\?([\\w$]+)\\)/.exec(pattern); // Add flags within a leading mode modifier to the overall pattern's flags\n\n    if (inlineFlags) {\n      flags = XRegExp._clipDuplicates(flags + inlineFlags[1]);\n    }\n\n    var data = {};\n\n    for (var p in subs) {\n      if (subs.hasOwnProperty(p)) {\n        // Passing to XRegExp enables extended syntax and ensures independent validity,\n        // lest an unescaped `(`, `)`, `[`, or trailing `\\` breaks the `(?:)` wrapper. For\n        // subpatterns provided as native regexes, it dies on octals and adds the property\n        // used to hold extended regex instance data, for simplicity.\n        var sub = asXRegExp(subs[p], addFlagX);\n        data[p] = {\n          // Deanchoring allows embedding independently useful anchored regexes. If you\n          // really need to keep your anchors, double them (i.e., `^^...$$`).\n          pattern: deanchor(sub.source),\n          names: sub[REGEX_DATA].captureNames || []\n        };\n      }\n    } // Passing to XRegExp dies on octals and ensures the outer pattern is independently valid;\n    // helps keep this simple. Named captures will be put back.\n\n\n    var patternAsRegex = asXRegExp(pattern, addFlagX); // 'Caps' is short for 'captures'\n\n    var numCaps = 0;\n    var numPriorCaps;\n    var numOuterCaps = 0;\n    var outerCapsMap = [0];\n    var outerCapNames = patternAsRegex[REGEX_DATA].captureNames || [];\n    var output = patternAsRegex.source.replace(parts, function ($0, $1, $2, $3, $4) {\n      var subName = $1 || $2;\n      var capName;\n      var intro;\n      var localCapIndex; // Named subpattern\n\n      if (subName) {\n        var _context3;\n\n        if (!data.hasOwnProperty(subName)) {\n          throw new ReferenceError(\"Undefined property \".concat($0));\n        } // Named subpattern was wrapped in a capturing group\n\n\n        if ($1) {\n          capName = outerCapNames[numOuterCaps];\n          outerCapsMap[++numOuterCaps] = ++numCaps; // If it's a named group, preserve the name. Otherwise, use the subpattern name\n          // as the capture name\n\n          intro = \"(?<\".concat(capName || subName, \">\");\n        } else {\n          intro = '(?:';\n        }\n\n        numPriorCaps = numCaps;\n        var rewrittenSubpattern = data[subName].pattern.replace(subParts, function (match, paren, backref) {\n          // Capturing group\n          if (paren) {\n            capName = data[subName].names[numCaps - numPriorCaps];\n            ++numCaps; // If the current capture has a name, preserve the name\n\n            if (capName) {\n              return \"(?<\".concat(capName, \">\");\n            } // Backreference\n\n          } else if (backref) {\n            localCapIndex = +backref - 1; // Rewrite the backreference\n\n            return data[subName].names[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n            \"\\\\k<\".concat(data[subName].names[localCapIndex], \">\") : \"\\\\\".concat(+backref + numPriorCaps);\n          }\n\n          return match;\n        });\n        return (0, _concat[\"default\"])(_context3 = \"\".concat(intro)).call(_context3, rewrittenSubpattern, \")\");\n      } // Capturing group\n\n\n      if ($3) {\n        capName = outerCapNames[numOuterCaps];\n        outerCapsMap[++numOuterCaps] = ++numCaps; // If the current capture has a name, preserve the name\n\n        if (capName) {\n          return \"(?<\".concat(capName, \">\");\n        } // Backreference\n\n      } else if ($4) {\n        localCapIndex = +$4 - 1; // Rewrite the backreference\n\n        return outerCapNames[localCapIndex] ? // Need to preserve the backreference name in case using flag `n`\n        \"\\\\k<\".concat(outerCapNames[localCapIndex], \">\") : \"\\\\\".concat(outerCapsMap[+$4]);\n      }\n\n      return $0;\n    });\n    return XRegExp(output, flags);\n  };\n};\n\nexports[\"default\"] = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}