{"ast":null,"code":"\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = void 0;\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n/*!\n * XRegExp.matchRecursive 5.0.2\n * <xregexp.com>\n * Steven Levithan (c) 2009-present MIT License\n */\n\n\nvar _default = function _default(XRegExp) {\n  /**\n   * Returns a match detail object composed of the provided values.\n   *\n   * @private\n   */\n  function row(name, value, start, end) {\n    return {\n      name: name,\n      value: value,\n      start: start,\n      end: end\n    };\n  }\n  /**\n   * Returns an array of match strings between outermost left and right delimiters, or an array of\n   * objects with detailed match parts and position data. An error is thrown if delimiters are\n   * unbalanced within the data.\n   *\n   * @memberOf XRegExp\n   * @param {String} str String to search.\n   * @param {String} left Left delimiter as an XRegExp pattern.\n   * @param {String} right Right delimiter as an XRegExp pattern.\n   * @param {String} [flags] Any combination of XRegExp flags, used for the left and right delimiters.\n   * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\n   * @returns {!Array} Array of matches, or an empty array.\n   * @example\n   *\n   * // Basic usage\n   * let str = '(t((e))s)t()(ing)';\n   * XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n   * // -> ['t((e))s', '', 'ing']\n   *\n   * // Extended information mode with valueNames\n   * str = 'Here is <div> <div>an</div></div> example';\n   * XRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n   *   valueNames: ['between', 'left', 'match', 'right']\n   * });\n   * // -> [\n   * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n   * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\n   * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n   * // {name: 'right',   value: '</div>',         start: 27, end: 33},\n   * // {name: 'between', value: ' example',       start: 33, end: 41}\n   * // ]\n   *\n   * // Omitting unneeded parts with null valueNames, and using escapeChar\n   * str = '...{1}.\\\\{{function(x,y){return {y:x}}}';\n   * XRegExp.matchRecursive(str, '{', '}', 'g', {\n   *   valueNames: ['literal', null, 'value', null],\n   *   escapeChar: '\\\\'\n   * });\n   * // -> [\n   * // {name: 'literal', value: '...',  start: 0, end: 3},\n   * // {name: 'value',   value: '1',    start: 4, end: 5},\n   * // {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n   * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n   * // ]\n   *\n   * // Sticky mode via flag y\n   * str = '<1><<<2>>><3>4<5>';\n   * XRegExp.matchRecursive(str, '<', '>', 'gy');\n   * // -> ['1', '<<2>>', '3']\n   */\n\n\n  XRegExp.matchRecursive = function (str, left, right, flags, options) {\n    flags = flags || '';\n    options = options || {};\n    var global = (0, _indexOf[\"default\"])(flags).call(flags, 'g') !== -1;\n    var sticky = (0, _indexOf[\"default\"])(flags).call(flags, 'y') !== -1; // Flag `y` is controlled internally\n\n    var basicFlags = flags.replace(/y/g, '');\n    var _options = options,\n        escapeChar = _options.escapeChar;\n    var vN = options.valueNames;\n    var output = [];\n    var openTokens = 0;\n    var delimStart = 0;\n    var delimEnd = 0;\n    var lastOuterEnd = 0;\n    var outerStart;\n    var innerStart;\n    var leftMatch;\n    var rightMatch;\n    var esc;\n    left = XRegExp(left, basicFlags);\n    right = XRegExp(right, basicFlags);\n\n    if (escapeChar) {\n      var _context, _context2;\n\n      if (escapeChar.length > 1) {\n        throw new Error('Cannot use more than one escape character');\n      }\n\n      escapeChar = XRegExp.escape(escapeChar); // Example of concatenated `esc` regex:\n      // `escapeChar`: '%'\n      // `left`: '<'\n      // `right`: '>'\n      // Regex is: /(?:%[\\S\\s]|(?:(?!<|>)[^%])+)+/\n\n      esc = new RegExp((0, _concat[\"default\"])(_context = (0, _concat[\"default\"])(_context2 = \"(?:\".concat(escapeChar, \"[\\\\S\\\\s]|(?:(?!\")).call(_context2, // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.\n      // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax\n      // transformation resulting from those flags was already applied to `left` and\n      // `right` when they were passed through the XRegExp constructor above.\n      XRegExp.union([left, right], '', {\n        conjunction: 'or'\n      }).source, \")[^\")).call(_context, escapeChar, \"])+)+\"), // Flags `gy` not needed here\n      flags.replace(XRegExp._hasNativeFlag('s') ? /[^imsu]/g : /[^imu]/g, ''));\n    }\n\n    while (true) {\n      // If using an escape character, advance to the delimiter's next starting position,\n      // skipping any escaped characters in between\n      if (escapeChar) {\n        delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;\n      }\n\n      leftMatch = XRegExp.exec(str, left, delimEnd);\n      rightMatch = XRegExp.exec(str, right, delimEnd); // Keep the leftmost match only\n\n      if (leftMatch && rightMatch) {\n        if (leftMatch.index <= rightMatch.index) {\n          rightMatch = null;\n        } else {\n          leftMatch = null;\n        }\n      } // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\n      // LM | RM | OT | Result\n      // 1  | 0  | 1  | loop\n      // 1  | 0  | 0  | loop\n      // 0  | 1  | 1  | loop\n      // 0  | 1  | 0  | throw\n      // 0  | 0  | 1  | throw\n      // 0  | 0  | 0  | break\n      // The paths above don't include the sticky mode special case. The loop ends after the\n      // first completed match if not `global`.\n\n\n      if (leftMatch || rightMatch) {\n        delimStart = (leftMatch || rightMatch).index;\n        delimEnd = delimStart + (leftMatch || rightMatch)[0].length;\n      } else if (!openTokens) {\n        break;\n      }\n\n      if (sticky && !openTokens && delimStart > lastOuterEnd) {\n        break;\n      }\n\n      if (leftMatch) {\n        if (!openTokens) {\n          outerStart = delimStart;\n          innerStart = delimEnd;\n        }\n\n        ++openTokens;\n      } else if (rightMatch && openTokens) {\n        if (! --openTokens) {\n          if (vN) {\n            if (vN[0] && outerStart > lastOuterEnd) {\n              output.push(row(vN[0], (0, _slice[\"default\"])(str).call(str, lastOuterEnd, outerStart), lastOuterEnd, outerStart));\n            }\n\n            if (vN[1]) {\n              output.push(row(vN[1], (0, _slice[\"default\"])(str).call(str, outerStart, innerStart), outerStart, innerStart));\n            }\n\n            if (vN[2]) {\n              output.push(row(vN[2], (0, _slice[\"default\"])(str).call(str, innerStart, delimStart), innerStart, delimStart));\n            }\n\n            if (vN[3]) {\n              output.push(row(vN[3], (0, _slice[\"default\"])(str).call(str, delimStart, delimEnd), delimStart, delimEnd));\n            }\n          } else {\n            output.push((0, _slice[\"default\"])(str).call(str, innerStart, delimStart));\n          }\n\n          lastOuterEnd = delimEnd;\n\n          if (!global) {\n            break;\n          }\n        }\n      } else {\n        var _context3;\n\n        var delimSide = rightMatch ? 'right' : 'left';\n        var errorPos = rightMatch ? delimStart : outerStart;\n        throw new Error((0, _concat[\"default\"])(_context3 = \"Unbalanced \".concat(delimSide, \" delimiter found in string at position \")).call(_context3, errorPos));\n      } // If the delimiter matched an empty string, avoid an infinite loop\n\n\n      if (delimStart === delimEnd) {\n        ++delimEnd;\n      }\n    }\n\n    if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {\n      output.push(row(vN[0], (0, _slice[\"default\"])(str).call(str, lastOuterEnd), lastOuterEnd, str.length));\n    }\n\n    return output;\n  };\n};\n\nexports[\"default\"] = _default;\nmodule.exports = exports.default;","map":{"version":3,"sources":["E:/AcademicAdvisingSystem/client/node_modules/xregexp/lib/addons/matchrecursive.js"],"names":["_Object$defineProperty","require","_interopRequireDefault","exports","value","_indexOf","_concat","_slice","_default","XRegExp","row","name","start","end","matchRecursive","str","left","right","flags","options","global","call","sticky","basicFlags","replace","_options","escapeChar","vN","valueNames","output","openTokens","delimStart","delimEnd","lastOuterEnd","outerStart","innerStart","leftMatch","rightMatch","esc","_context","_context2","length","Error","escape","RegExp","concat","union","conjunction","source","_hasNativeFlag","exec","index","push","_context3","delimSide","errorPos","module","default"],"mappings":"AAAA;;AAEA,IAAIA,sBAAsB,GAAGC,OAAO,CAAC,8DAAD,CAApC;;AAEA,IAAIC,sBAAsB,GAAGD,OAAO,CAAC,sDAAD,CAApC;;AAEAD,sBAAsB,CAACG,OAAD,EAAU,YAAV,EAAwB;AAC5CC,EAAAA,KAAK,EAAE;AADqC,CAAxB,CAAtB;;AAIAD,OAAO,CAAC,SAAD,CAAP,GAAqB,KAAK,CAA1B;;AAEA,IAAIE,QAAQ,GAAGH,sBAAsB,CAACD,OAAO,CAAC,yDAAD,CAAR,CAArC;;AAEA,IAAIK,OAAO,GAAGJ,sBAAsB,CAACD,OAAO,CAAC,uDAAD,CAAR,CAApC;;AAEA,IAAIM,MAAM,GAAGL,sBAAsB,CAACD,OAAO,CAAC,sDAAD,CAAR,CAAnC;AAEA;AACA;AACA;AACA;AACA;;;AACA,IAAIO,QAAQ,GAAG,SAASA,QAAT,CAAkBC,OAAlB,EAA2B;AACxC;AACF;AACA;AACA;AACA;AACE,WAASC,GAAT,CAAaC,IAAb,EAAmBP,KAAnB,EAA0BQ,KAA1B,EAAiCC,GAAjC,EAAsC;AACpC,WAAO;AACLF,MAAAA,IAAI,EAAEA,IADD;AAELP,MAAAA,KAAK,EAAEA,KAFF;AAGLQ,MAAAA,KAAK,EAAEA,KAHF;AAILC,MAAAA,GAAG,EAAEA;AAJA,KAAP;AAMD;AACD;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGEJ,EAAAA,OAAO,CAACK,cAAR,GAAyB,UAAUC,GAAV,EAAeC,IAAf,EAAqBC,KAArB,EAA4BC,KAA5B,EAAmCC,OAAnC,EAA4C;AACnED,IAAAA,KAAK,GAAGA,KAAK,IAAI,EAAjB;AACAC,IAAAA,OAAO,GAAGA,OAAO,IAAI,EAArB;AACA,QAAIC,MAAM,GAAG,CAAC,GAAGf,QAAQ,CAAC,SAAD,CAAZ,EAAyBa,KAAzB,EAAgCG,IAAhC,CAAqCH,KAArC,EAA4C,GAA5C,MAAqD,CAAC,CAAnE;AACA,QAAII,MAAM,GAAG,CAAC,GAAGjB,QAAQ,CAAC,SAAD,CAAZ,EAAyBa,KAAzB,EAAgCG,IAAhC,CAAqCH,KAArC,EAA4C,GAA5C,MAAqD,CAAC,CAAnE,CAJmE,CAIG;;AAEtE,QAAIK,UAAU,GAAGL,KAAK,CAACM,OAAN,CAAc,IAAd,EAAoB,EAApB,CAAjB;AACA,QAAIC,QAAQ,GAAGN,OAAf;AAAA,QACIO,UAAU,GAAGD,QAAQ,CAACC,UAD1B;AAEA,QAAIC,EAAE,GAAGR,OAAO,CAACS,UAAjB;AACA,QAAIC,MAAM,GAAG,EAAb;AACA,QAAIC,UAAU,GAAG,CAAjB;AACA,QAAIC,UAAU,GAAG,CAAjB;AACA,QAAIC,QAAQ,GAAG,CAAf;AACA,QAAIC,YAAY,GAAG,CAAnB;AACA,QAAIC,UAAJ;AACA,QAAIC,UAAJ;AACA,QAAIC,SAAJ;AACA,QAAIC,UAAJ;AACA,QAAIC,GAAJ;AACAtB,IAAAA,IAAI,GAAGP,OAAO,CAACO,IAAD,EAAOO,UAAP,CAAd;AACAN,IAAAA,KAAK,GAAGR,OAAO,CAACQ,KAAD,EAAQM,UAAR,CAAf;;AAEA,QAAIG,UAAJ,EAAgB;AACd,UAAIa,QAAJ,EAAcC,SAAd;;AAEA,UAAId,UAAU,CAACe,MAAX,GAAoB,CAAxB,EAA2B;AACzB,cAAM,IAAIC,KAAJ,CAAU,2CAAV,CAAN;AACD;;AAEDhB,MAAAA,UAAU,GAAGjB,OAAO,CAACkC,MAAR,CAAejB,UAAf,CAAb,CAPc,CAO2B;AACzC;AACA;AACA;AACA;;AAEAY,MAAAA,GAAG,GAAG,IAAIM,MAAJ,CAAW,CAAC,GAAGtC,OAAO,CAAC,SAAD,CAAX,EAAwBiC,QAAQ,GAAG,CAAC,GAAGjC,OAAO,CAAC,SAAD,CAAX,EAAwBkC,SAAS,GAAG,MAAMK,MAAN,CAAanB,UAAb,EAAyB,iBAAzB,CAApC,EAAiFL,IAAjF,CAAsFmB,SAAtF,EAAiG;AACrJ;AACA;AACA;AACA/B,MAAAA,OAAO,CAACqC,KAAR,CAAc,CAAC9B,IAAD,EAAOC,KAAP,CAAd,EAA6B,EAA7B,EAAiC;AAC/B8B,QAAAA,WAAW,EAAE;AADkB,OAAjC,EAEGC,MANiD,EAMzC,KANyC,CAAnC,EAME3B,IANF,CAMOkB,QANP,EAMiBb,UANjB,EAM6B,OAN7B,CAAX,EAMkD;AACxDR,MAAAA,KAAK,CAACM,OAAN,CAAcf,OAAO,CAACwC,cAAR,CAAuB,GAAvB,IAA8B,UAA9B,GAA2C,SAAzD,EAAoE,EAApE,CAPM,CAAN;AAQD;;AAED,WAAO,IAAP,EAAa;AACX;AACA;AACA,UAAIvB,UAAJ,EAAgB;AACdM,QAAAA,QAAQ,IAAI,CAACvB,OAAO,CAACyC,IAAR,CAAanC,GAAb,EAAkBuB,GAAlB,EAAuBN,QAAvB,EAAiC,QAAjC,KAA8C,CAAC,EAAD,CAA/C,EAAqD,CAArD,EAAwDS,MAApE;AACD;;AAEDL,MAAAA,SAAS,GAAG3B,OAAO,CAACyC,IAAR,CAAanC,GAAb,EAAkBC,IAAlB,EAAwBgB,QAAxB,CAAZ;AACAK,MAAAA,UAAU,GAAG5B,OAAO,CAACyC,IAAR,CAAanC,GAAb,EAAkBE,KAAlB,EAAyBe,QAAzB,CAAb,CARW,CAQsC;;AAEjD,UAAII,SAAS,IAAIC,UAAjB,EAA6B;AAC3B,YAAID,SAAS,CAACe,KAAV,IAAmBd,UAAU,CAACc,KAAlC,EAAyC;AACvCd,UAAAA,UAAU,GAAG,IAAb;AACD,SAFD,MAEO;AACLD,UAAAA,SAAS,GAAG,IAAZ;AACD;AACF,OAhBU,CAgBT;AACF;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,UAAIA,SAAS,IAAIC,UAAjB,EAA6B;AAC3BN,QAAAA,UAAU,GAAG,CAACK,SAAS,IAAIC,UAAd,EAA0Bc,KAAvC;AACAnB,QAAAA,QAAQ,GAAGD,UAAU,GAAG,CAACK,SAAS,IAAIC,UAAd,EAA0B,CAA1B,EAA6BI,MAArD;AACD,OAHD,MAGO,IAAI,CAACX,UAAL,EAAiB;AACtB;AACD;;AAED,UAAIR,MAAM,IAAI,CAACQ,UAAX,IAAyBC,UAAU,GAAGE,YAA1C,EAAwD;AACtD;AACD;;AAED,UAAIG,SAAJ,EAAe;AACb,YAAI,CAACN,UAAL,EAAiB;AACfI,UAAAA,UAAU,GAAGH,UAAb;AACAI,UAAAA,UAAU,GAAGH,QAAb;AACD;;AAED,UAAEF,UAAF;AACD,OAPD,MAOO,IAAIO,UAAU,IAAIP,UAAlB,EAA8B;AACnC,YAAI,CAAE,GAAEA,UAAR,EAAoB;AAClB,cAAIH,EAAJ,EAAQ;AACN,gBAAIA,EAAE,CAAC,CAAD,CAAF,IAASO,UAAU,GAAGD,YAA1B,EAAwC;AACtCJ,cAAAA,MAAM,CAACuB,IAAP,CAAY1C,GAAG,CAACiB,EAAE,CAAC,CAAD,CAAH,EAAQ,CAAC,GAAGpB,MAAM,CAAC,SAAD,CAAV,EAAuBQ,GAAvB,EAA4BM,IAA5B,CAAiCN,GAAjC,EAAsCkB,YAAtC,EAAoDC,UAApD,CAAR,EAAyED,YAAzE,EAAuFC,UAAvF,CAAf;AACD;;AAED,gBAAIP,EAAE,CAAC,CAAD,CAAN,EAAW;AACTE,cAAAA,MAAM,CAACuB,IAAP,CAAY1C,GAAG,CAACiB,EAAE,CAAC,CAAD,CAAH,EAAQ,CAAC,GAAGpB,MAAM,CAAC,SAAD,CAAV,EAAuBQ,GAAvB,EAA4BM,IAA5B,CAAiCN,GAAjC,EAAsCmB,UAAtC,EAAkDC,UAAlD,CAAR,EAAuED,UAAvE,EAAmFC,UAAnF,CAAf;AACD;;AAED,gBAAIR,EAAE,CAAC,CAAD,CAAN,EAAW;AACTE,cAAAA,MAAM,CAACuB,IAAP,CAAY1C,GAAG,CAACiB,EAAE,CAAC,CAAD,CAAH,EAAQ,CAAC,GAAGpB,MAAM,CAAC,SAAD,CAAV,EAAuBQ,GAAvB,EAA4BM,IAA5B,CAAiCN,GAAjC,EAAsCoB,UAAtC,EAAkDJ,UAAlD,CAAR,EAAuEI,UAAvE,EAAmFJ,UAAnF,CAAf;AACD;;AAED,gBAAIJ,EAAE,CAAC,CAAD,CAAN,EAAW;AACTE,cAAAA,MAAM,CAACuB,IAAP,CAAY1C,GAAG,CAACiB,EAAE,CAAC,CAAD,CAAH,EAAQ,CAAC,GAAGpB,MAAM,CAAC,SAAD,CAAV,EAAuBQ,GAAvB,EAA4BM,IAA5B,CAAiCN,GAAjC,EAAsCgB,UAAtC,EAAkDC,QAAlD,CAAR,EAAqED,UAArE,EAAiFC,QAAjF,CAAf;AACD;AACF,WAhBD,MAgBO;AACLH,YAAAA,MAAM,CAACuB,IAAP,CAAY,CAAC,GAAG7C,MAAM,CAAC,SAAD,CAAV,EAAuBQ,GAAvB,EAA4BM,IAA5B,CAAiCN,GAAjC,EAAsCoB,UAAtC,EAAkDJ,UAAlD,CAAZ;AACD;;AAEDE,UAAAA,YAAY,GAAGD,QAAf;;AAEA,cAAI,CAACZ,MAAL,EAAa;AACX;AACD;AACF;AACF,OA5BM,MA4BA;AACL,YAAIiC,SAAJ;;AAEA,YAAIC,SAAS,GAAGjB,UAAU,GAAG,OAAH,GAAa,MAAvC;AACA,YAAIkB,QAAQ,GAAGlB,UAAU,GAAGN,UAAH,GAAgBG,UAAzC;AACA,cAAM,IAAIQ,KAAJ,CAAU,CAAC,GAAGpC,OAAO,CAAC,SAAD,CAAX,EAAwB+C,SAAS,GAAG,cAAcR,MAAd,CAAqBS,SAArB,EAAgC,yCAAhC,CAApC,EAAgHjC,IAAhH,CAAqHgC,SAArH,EAAgIE,QAAhI,CAAV,CAAN;AACD,OAhFU,CAgFT;;;AAGF,UAAIxB,UAAU,KAAKC,QAAnB,EAA6B;AAC3B,UAAEA,QAAF;AACD;AACF;;AAED,QAAIZ,MAAM,IAAI,CAACE,MAAX,IAAqBK,EAArB,IAA2BA,EAAE,CAAC,CAAD,CAA7B,IAAoCZ,GAAG,CAAC0B,MAAJ,GAAaR,YAArD,EAAmE;AACjEJ,MAAAA,MAAM,CAACuB,IAAP,CAAY1C,GAAG,CAACiB,EAAE,CAAC,CAAD,CAAH,EAAQ,CAAC,GAAGpB,MAAM,CAAC,SAAD,CAAV,EAAuBQ,GAAvB,EAA4BM,IAA5B,CAAiCN,GAAjC,EAAsCkB,YAAtC,CAAR,EAA6DA,YAA7D,EAA2ElB,GAAG,CAAC0B,MAA/E,CAAf;AACD;;AAED,WAAOZ,MAAP;AACD,GA3ID;AA4ID,CA9MD;;AAgNA1B,OAAO,CAAC,SAAD,CAAP,GAAqBK,QAArB;AACAgD,MAAM,CAACrD,OAAP,GAAiBA,OAAO,CAACsD,OAAzB","sourcesContent":["\"use strict\";\n\nvar _Object$defineProperty = require(\"@babel/runtime-corejs3/core-js-stable/object/define-property\");\n\nvar _interopRequireDefault = require(\"@babel/runtime-corejs3/helpers/interopRequireDefault\");\n\n_Object$defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nexports[\"default\"] = void 0;\n\nvar _indexOf = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/index-of\"));\n\nvar _concat = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/concat\"));\n\nvar _slice = _interopRequireDefault(require(\"@babel/runtime-corejs3/core-js-stable/instance/slice\"));\n\n/*!\n * XRegExp.matchRecursive 5.0.2\n * <xregexp.com>\n * Steven Levithan (c) 2009-present MIT License\n */\nvar _default = function _default(XRegExp) {\n  /**\n   * Returns a match detail object composed of the provided values.\n   *\n   * @private\n   */\n  function row(name, value, start, end) {\n    return {\n      name: name,\n      value: value,\n      start: start,\n      end: end\n    };\n  }\n  /**\n   * Returns an array of match strings between outermost left and right delimiters, or an array of\n   * objects with detailed match parts and position data. An error is thrown if delimiters are\n   * unbalanced within the data.\n   *\n   * @memberOf XRegExp\n   * @param {String} str String to search.\n   * @param {String} left Left delimiter as an XRegExp pattern.\n   * @param {String} right Right delimiter as an XRegExp pattern.\n   * @param {String} [flags] Any combination of XRegExp flags, used for the left and right delimiters.\n   * @param {Object} [options] Lets you specify `valueNames` and `escapeChar` options.\n   * @returns {!Array} Array of matches, or an empty array.\n   * @example\n   *\n   * // Basic usage\n   * let str = '(t((e))s)t()(ing)';\n   * XRegExp.matchRecursive(str, '\\\\(', '\\\\)', 'g');\n   * // -> ['t((e))s', '', 'ing']\n   *\n   * // Extended information mode with valueNames\n   * str = 'Here is <div> <div>an</div></div> example';\n   * XRegExp.matchRecursive(str, '<div\\\\s*>', '</div>', 'gi', {\n   *   valueNames: ['between', 'left', 'match', 'right']\n   * });\n   * // -> [\n   * // {name: 'between', value: 'Here is ',       start: 0,  end: 8},\n   * // {name: 'left',    value: '<div>',          start: 8,  end: 13},\n   * // {name: 'match',   value: ' <div>an</div>', start: 13, end: 27},\n   * // {name: 'right',   value: '</div>',         start: 27, end: 33},\n   * // {name: 'between', value: ' example',       start: 33, end: 41}\n   * // ]\n   *\n   * // Omitting unneeded parts with null valueNames, and using escapeChar\n   * str = '...{1}.\\\\{{function(x,y){return {y:x}}}';\n   * XRegExp.matchRecursive(str, '{', '}', 'g', {\n   *   valueNames: ['literal', null, 'value', null],\n   *   escapeChar: '\\\\'\n   * });\n   * // -> [\n   * // {name: 'literal', value: '...',  start: 0, end: 3},\n   * // {name: 'value',   value: '1',    start: 4, end: 5},\n   * // {name: 'literal', value: '.\\\\{', start: 6, end: 9},\n   * // {name: 'value',   value: 'function(x,y){return {y:x}}', start: 10, end: 37}\n   * // ]\n   *\n   * // Sticky mode via flag y\n   * str = '<1><<<2>>><3>4<5>';\n   * XRegExp.matchRecursive(str, '<', '>', 'gy');\n   * // -> ['1', '<<2>>', '3']\n   */\n\n\n  XRegExp.matchRecursive = function (str, left, right, flags, options) {\n    flags = flags || '';\n    options = options || {};\n    var global = (0, _indexOf[\"default\"])(flags).call(flags, 'g') !== -1;\n    var sticky = (0, _indexOf[\"default\"])(flags).call(flags, 'y') !== -1; // Flag `y` is controlled internally\n\n    var basicFlags = flags.replace(/y/g, '');\n    var _options = options,\n        escapeChar = _options.escapeChar;\n    var vN = options.valueNames;\n    var output = [];\n    var openTokens = 0;\n    var delimStart = 0;\n    var delimEnd = 0;\n    var lastOuterEnd = 0;\n    var outerStart;\n    var innerStart;\n    var leftMatch;\n    var rightMatch;\n    var esc;\n    left = XRegExp(left, basicFlags);\n    right = XRegExp(right, basicFlags);\n\n    if (escapeChar) {\n      var _context, _context2;\n\n      if (escapeChar.length > 1) {\n        throw new Error('Cannot use more than one escape character');\n      }\n\n      escapeChar = XRegExp.escape(escapeChar); // Example of concatenated `esc` regex:\n      // `escapeChar`: '%'\n      // `left`: '<'\n      // `right`: '>'\n      // Regex is: /(?:%[\\S\\s]|(?:(?!<|>)[^%])+)+/\n\n      esc = new RegExp((0, _concat[\"default\"])(_context = (0, _concat[\"default\"])(_context2 = \"(?:\".concat(escapeChar, \"[\\\\S\\\\s]|(?:(?!\")).call(_context2, // Using `XRegExp.union` safely rewrites backreferences in `left` and `right`.\n      // Intentionally not passing `basicFlags` to `XRegExp.union` since any syntax\n      // transformation resulting from those flags was already applied to `left` and\n      // `right` when they were passed through the XRegExp constructor above.\n      XRegExp.union([left, right], '', {\n        conjunction: 'or'\n      }).source, \")[^\")).call(_context, escapeChar, \"])+)+\"), // Flags `gy` not needed here\n      flags.replace(XRegExp._hasNativeFlag('s') ? /[^imsu]/g : /[^imu]/g, ''));\n    }\n\n    while (true) {\n      // If using an escape character, advance to the delimiter's next starting position,\n      // skipping any escaped characters in between\n      if (escapeChar) {\n        delimEnd += (XRegExp.exec(str, esc, delimEnd, 'sticky') || [''])[0].length;\n      }\n\n      leftMatch = XRegExp.exec(str, left, delimEnd);\n      rightMatch = XRegExp.exec(str, right, delimEnd); // Keep the leftmost match only\n\n      if (leftMatch && rightMatch) {\n        if (leftMatch.index <= rightMatch.index) {\n          rightMatch = null;\n        } else {\n          leftMatch = null;\n        }\n      } // Paths (LM: leftMatch, RM: rightMatch, OT: openTokens):\n      // LM | RM | OT | Result\n      // 1  | 0  | 1  | loop\n      // 1  | 0  | 0  | loop\n      // 0  | 1  | 1  | loop\n      // 0  | 1  | 0  | throw\n      // 0  | 0  | 1  | throw\n      // 0  | 0  | 0  | break\n      // The paths above don't include the sticky mode special case. The loop ends after the\n      // first completed match if not `global`.\n\n\n      if (leftMatch || rightMatch) {\n        delimStart = (leftMatch || rightMatch).index;\n        delimEnd = delimStart + (leftMatch || rightMatch)[0].length;\n      } else if (!openTokens) {\n        break;\n      }\n\n      if (sticky && !openTokens && delimStart > lastOuterEnd) {\n        break;\n      }\n\n      if (leftMatch) {\n        if (!openTokens) {\n          outerStart = delimStart;\n          innerStart = delimEnd;\n        }\n\n        ++openTokens;\n      } else if (rightMatch && openTokens) {\n        if (! --openTokens) {\n          if (vN) {\n            if (vN[0] && outerStart > lastOuterEnd) {\n              output.push(row(vN[0], (0, _slice[\"default\"])(str).call(str, lastOuterEnd, outerStart), lastOuterEnd, outerStart));\n            }\n\n            if (vN[1]) {\n              output.push(row(vN[1], (0, _slice[\"default\"])(str).call(str, outerStart, innerStart), outerStart, innerStart));\n            }\n\n            if (vN[2]) {\n              output.push(row(vN[2], (0, _slice[\"default\"])(str).call(str, innerStart, delimStart), innerStart, delimStart));\n            }\n\n            if (vN[3]) {\n              output.push(row(vN[3], (0, _slice[\"default\"])(str).call(str, delimStart, delimEnd), delimStart, delimEnd));\n            }\n          } else {\n            output.push((0, _slice[\"default\"])(str).call(str, innerStart, delimStart));\n          }\n\n          lastOuterEnd = delimEnd;\n\n          if (!global) {\n            break;\n          }\n        }\n      } else {\n        var _context3;\n\n        var delimSide = rightMatch ? 'right' : 'left';\n        var errorPos = rightMatch ? delimStart : outerStart;\n        throw new Error((0, _concat[\"default\"])(_context3 = \"Unbalanced \".concat(delimSide, \" delimiter found in string at position \")).call(_context3, errorPos));\n      } // If the delimiter matched an empty string, avoid an infinite loop\n\n\n      if (delimStart === delimEnd) {\n        ++delimEnd;\n      }\n    }\n\n    if (global && !sticky && vN && vN[0] && str.length > lastOuterEnd) {\n      output.push(row(vN[0], (0, _slice[\"default\"])(str).call(str, lastOuterEnd), lastOuterEnd, str.length));\n    }\n\n    return output;\n  };\n};\n\nexports[\"default\"] = _default;\nmodule.exports = exports.default;"]},"metadata":{},"sourceType":"script"}